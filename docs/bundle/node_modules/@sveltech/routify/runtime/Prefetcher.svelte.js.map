{"version":3,"file":"Prefetcher.svelte.js","sources":["../../../../../../node_modules/@sveltech/routify/runtime/Prefetcher.svelte"],"sourcesContent":["<script context=\"module\">\n  import { writable, derived, get } from 'svelte/store'\n\n  /** config */\n  const iframeNum = 2\n  const defaults = {\n    validFor: 60,\n    timeout: 5000,\n    gracePeriod: 1000,\n  }\n\n  /** stores and subscriptions */\n  const queue = writable([])\n  const actives = derived(queue, q => q.slice(0, iframeNum))\n  actives.subscribe(actives =>\n    actives.forEach(({ options }) => {\n      setTimeout(() => removeFromQueue(options.prefetch), options.timeout)\n    })\n  )\n\n  /**\n   * @param {string} path\n   * @param {defaults} options\n   */\n  export function prefetch(path, options = {}) {\n    prefetch.id = prefetch.id || 1\n    path = !path.href ? path : path.href.replace(/^(?:\\/\\/|[^/]+)*\\//, '/')\n    //replace first ? since were mixing user queries with routify queries\n    path = path.replace('?', '&')\n\n    options = { ...defaults, ...options, path }\n    options.prefetch = prefetch.id++\n\n    //don't prefetch within prefetch or SSR\n    if (window.routify.prefetched || navigator.userAgent.match('jsdom'))\n      return false\n\n    // add to queue\n    queue.update(q => {\n      if (!q.some(e => e.options.path === path))\n        q.push({\n          url: `/__app.html?${optionsToQuery(options)}`,\n          options,\n        })\n      return q\n    })\n  }\n\n  /**\n   * convert options to query string\n   * {a:1,b:2} becomes __routify_a=1&routify_b=2\n   * @param {defaults & {path: string, prefetch: number}} options\n   */\n  function optionsToQuery(options) {\n    return Object.entries(options)\n      .map(([key, val]) => `__routify_${key}=${val}`)\n      .join('&')\n  }\n\n  /**\n   * @param {number|MessageEvent} idOrEvent\n   */\n  function removeFromQueue(idOrEvent) {\n    const id = idOrEvent.data ? idOrEvent.data.prefetchId : idOrEvent\n    if (!id) return null\n\n    const entry = get(queue).find(\n      entry => entry && entry.options.prefetch == id\n    )\n    // removeFromQueue is called by both eventListener and timeout,\n    // but we can only remove the item once\n    if (entry) {\n      const { gracePeriod } = entry.options\n      const gracePromise = new Promise(resolve =>\n        setTimeout(resolve, gracePeriod)\n      )\n      const idlePromise = new Promise(resolve => {\n        window.requestIdleCallback\n          ? window.requestIdleCallback(resolve)\n          : setTimeout(resolve, gracePeriod + 1000)\n      })\n      Promise.all([gracePromise, idlePromise]).then(() => {\n        queue.update(q => q.filter(q => q.options.prefetch != id))\n      })\n    }\n  }\n\n  // Listen to message from child window\n  addEventListener('message', removeFromQueue, false)\n</script>\n\n<div id=\"__routify_iframes\" style=\"display: none\">\n  {#each $actives as prefetch (prefetch.options.prefetch)}\n    <iframe src={prefetch.url} frameborder=\"0\" title=\"routify prefetcher\" />\n  {/each}\n</div>\n"],"names":["ctx","url","options","prefetch","length","queue","writable","actives","derived","q","slice","removeFromQueue","idOrEvent","id","data","prefetchId","entry","get","find","gracePeriod","gracePromise","Promise","resolve","setTimeout","idlePromise","window","requestIdleCallback","all","then","update","filter","subscribe","forEach","timeout","addEventListener"],"mappings":"qdA6FiBA,KAASC,kIAATD,KAASC,wEADjBD,gBAAsBA,KAASE,QAAQC,yBAA5CC,6PAAKJ,yGAhFDK,EAAQC,MACRC,EAAUC,EAAQH,GAAOI,GAAKA,EAAEC,MAAM,EAT1B,cA0DTC,EAAgBC,SACjBC,EAAKD,EAAUE,KAAOF,EAAUE,KAAKC,WAAaH,MACnDC,SAAW,WAEVG,EAAQC,EAAIZ,GAAOa,MACvBF,GAASA,GAASA,EAAMd,QAAQC,UAAYU,OAI1CG,qBACMG,GAAgBH,EAAMd,QACxBkB,MAAmBC,SAAQC,GAC/BC,WAAWD,EAASH,KAEhBK,MAAkBH,SAAQC,IAC9BG,OAAOC,oBACHD,OAAOC,oBAAoBJ,GAC3BC,WAAWD,EAASH,EAAc,QAExCE,QAAQM,KAAKP,EAAcI,IAAcI,WACvCvB,EAAMwB,QAAOpB,GAAKA,EAAEqB,QAAOrB,GAAKA,EAAEP,QAAQC,UAAYU,kEApE5DN,EAAQwB,WAAUxB,GAChBA,EAAQyB,WAAW9B,QAAAA,MACjBqB,gBAAiBZ,EAAgBT,EAAQC,WAAWD,EAAQ+B,cAwEhEC,iBAAiB,UAAWvB,GAAiB"}