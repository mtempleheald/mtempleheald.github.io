import{pathToRegex as e,pathToParamKeys as t,pathToRank as i}from"../utils/index.js";import{createNodeMiddleware as n}from"../middleware.js";const r=n((({file:t})=>{(t.isPage||t.isFallback)&&(t.regex=e(t.path,t.isFallback))})),a=n((({file:e})=>{e.paramKeys=t(e.path)})),l=n((({file:e})=>{e.isFallback||e.isIndex?e.shortPath=e.path.replace(/\/[^/]+$/,""):e.shortPath=e.path})),s=n((({file:e})=>{e.ranking=i(e)})),o=n((({file:e})=>{const t=e,i=e.meta&&e.meta.children||[];i.length&&(t.children=t.children||[],t.children.push(...i.map((e=>({isMeta:!0,...e,meta:e})))))})),c=n((e=>{const{file:t}=e,{isLayout:i,isFallback:n,meta:r}=t;t.isIndexable=!i&&!n&&!1!==r.index,t.isNonIndexable=!t.isIndexable})),f=n((({file:e,parent:t})=>{Object.defineProperty(e,"parent",{get:()=>t}),Object.defineProperty(e,"nextSibling",{get:()=>d(e,1)}),Object.defineProperty(e,"prevSibling",{get:()=>d(e,-1)}),Object.defineProperty(e,"lineage",{get:()=>p(t)})}));function p(e,t=[]){return e&&(t.unshift(e),p(e.parent,t)),t}function d(e,t){if(!e.root){const i=e.parent.children.filter((e=>e.isIndexable)),n=i.indexOf(e);return i[n+t]}}const u=n((({file:e,parent:t})=>{e.isIndex&&Object.defineProperty(t,"index",{get:()=>e}),e.isLayout&&Object.defineProperty(t,"layout",{get:()=>e})})),b=n((({file:e,scope:t})=>{function i(e){const{parent:t}=e,n=t&&t.layout,r=n&&n.isReset,a=t&&!r&&i(t)||[];return n&&a.push(n),a}Object.defineProperty(e,"layouts",{get:()=>i(e)})})),h=e=>{n((e=>{(e.file.isPage||e.file.isFallback)&&e.state.treePayload.routes.push(e.file)})).sync(e),e.routes.sort(((e,t)=>e.ranking>=t.ranking?-1:1))},y=n((({file:e})=>{const t=e.root?function(){}:e.children?(e.isFile,function(){}):(e.isReset||e.isLayout||e.isFallback,function(){});Object.setPrototypeOf(e,t.prototype)}));export{o as addMetaChildren,u as assignIndex,b as assignLayout,f as assignRelations,h as createFlatList,c as setIsIndexable,a as setParamKeys,y as setPrototype,s as setRank,r as setRegex,l as setShortPath};
//# sourceMappingURL=tree.js.map
