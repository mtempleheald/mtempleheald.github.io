{"version":3,"file":"helpers.js","sources":["../../../../../../node_modules/@sveltech/routify/runtime/helpers.js"],"sourcesContent":["import { getContext, tick } from 'svelte'\nimport { derived, get, writable } from 'svelte/store'\nimport { route, routes, location, rootContext, prefetchPath } from './store'\nimport { pathToParamKeys } from './utils'\nimport { onAppLoaded } from './utils/onAppLoaded.js'\nimport config from '../runtime.config'\nimport { urlToRoute } from './utils/urlToRoute'\nimport { prefetch as _prefetch } from './Prefetcher.svelte'\n/// <reference path=\"../typedef.js\" />\n\n/** @ts-check */\n/**\n * @typedef {Object} RoutifyContext\n * @prop {ClientNode} component\n * @prop {ClientNode} layout\n * @prop {any} componentFile \n * \n *  @returns {import('svelte/store').Readable<RoutifyContext>} */\nfunction getRoutifyContext() {\n  return getContext('routify') || rootContext\n}\n\n\n/**\n * @typedef {import('svelte/store').Readable<ClientNodeApi>} ClientNodeHelperStore\n * @type { ClientNodeHelperStore } \n */\nexport const page = {\n  subscribe(run) {\n    return derived(route, route => route.api).subscribe(run)\n  }\n}\n\n/** @type {ClientNodeHelperStore} */\nexport const layout = {\n  subscribe(run) {\n    const ctx = getRoutifyContext()\n    return derived(ctx, ctx => ctx.layout.api).subscribe(run)\n  }\n}\n\n/**\n* @typedef {{component: ClientNode}}  ContextHelper\n* @typedef {import('svelte/store').Readable<ContextHelper>} ContextHelperStore\n* @type {ContextHelperStore}\n*/\nexport const context = {\n  subscribe(run) {\n    return getRoutifyContext().subscribe(run)\n  }\n}\n\n/**\n * @typedef {function():void} ReadyHelper\n * @typedef {import('svelte/store').Readable<ReadyHelper>} ReadyHelperStore\n * @type {ReadyHelperStore}\n*/\nexport const ready = {\n  subscribe(run) {\n    window['routify'].stopAutoReady = true\n    async function ready() {\n      await tick()\n      await onAppLoaded({ path: get(route).path, metatags })\n    }\n    run(ready)\n    return () => { }\n  }\n}\n\n/**\n * @callback AfterPageLoadHelper\n * @param {function} callback\n * \n * @typedef {import('svelte/store').Readable<AfterPageLoadHelper> & {_hooks:Array<function>}} AfterPageLoadHelperStore\n * @type {AfterPageLoadHelperStore}\n */\nexport const afterPageLoad = {\n  _hooks: [],\n  subscribe: hookHandler\n}\n\n/** \n * @callback BeforeUrlChangeHelper\n * @param {function} callback\n *\n * @typedef {import('svelte/store').Readable<BeforeUrlChangeHelper> & {_hooks:Array<function>}} BeforeUrlChangeHelperStore\n * @type {BeforeUrlChangeHelperStore}\n **/\nexport const beforeUrlChange = {\n  _hooks: [],\n  subscribe: hookHandler\n}\n\nfunction hookHandler(listener) {\n  const hooks = this._hooks\n  const index = hooks.length\n  listener(callback => { hooks[index] = callback })\n  return () => delete hooks[index]\n}\n\n/**\n * We have to grab params and leftover from the context and not directly from the store.\n * Otherwise the context is updated before the component is destroyed. * \n * @typedef {Object.<string, *>} ParamsHelper\n * @typedef {import('svelte/store').Readable<ParamsHelper>} ParamsHelperStore\n * @type {ParamsHelperStore}\n **/\nexport const params = {\n  subscribe(run) {\n    const ctx = getRoutifyContext()\n    return derived(ctx, ctx => ctx.route.params).subscribe(run)\n  }\n}\n\n/**\n * @typedef {string} LeftoverHelper\n * @typedef {import('svelte/store').Readable<string>} LeftoverHelperStore\n * @type {LeftoverHelperStore} \n **/\nexport const leftover = {\n  subscribe(listener) {\n    return derived(\n      route,\n      route => route.leftover\n    ).subscribe(listener)\n  },\n}\n\n\n\n\n/**\n * @typedef {import('svelte/store').Readable<Meta>} MetaHelperStore \n * @type {MetaHelperStore}\n * */\nexport const meta = {\n  subscribe(listener) {\n    const ctx = getRoutifyContext()\n    return derived(ctx, ctx => ctx.layout.meta).subscribe(listener)\n  },\n}\n\n/**\n * @callback UrlHelper\n * @param {String=} path\n * @param {UrlParams=} params\n * @param {UrlOptions=} options\n * @return {String}\n *\n * @typedef {import('svelte/store').Readable<UrlHelper>} UrlHelperStore\n * @type {UrlHelperStore} \n * */\nexport const url = {\n  subscribe(listener) {\n    const ctx = getRoutifyContext()\n    return derived(\n      [ctx, route, routes, location],\n      args => makeUrlHelper(...args)\n    ).subscribe(\n      listener\n    )\n  }\n}\n\n/** \n * @param {{component: ClientNode}} $ctx \n * @param {RouteNode} $oldRoute \n * @param {RouteNode[]} $routes \n * @param {{base: string, path: string}} $location\n * @returns {UrlHelper}\n */\nexport function makeUrlHelper($ctx, $oldRoute, $routes, $location) {\n  return function url(path, params, options) {\n    const { component } = $ctx\n    path = path || './'\n\n    const strict = options && options.strict !== false\n    if (!strict) path = path.replace(/index$/, '')\n\n    if (path.match(/^\\.\\.?\\//)) {\n      //RELATIVE PATH\n      let [, breadcrumbs, relativePath] = path.match(/^([\\.\\/]+)(.*)/)\n      let dir = component.path.replace(/\\/$/, '')\n      const traverse = breadcrumbs.match(/\\.\\.\\//g) || []\n      traverse.forEach(() => dir = dir.replace(/\\/[^\\/]+\\/?$/, ''))\n      path = `${dir}/${relativePath}`.replace(/\\/$/, '')\n\n    } else if (path.match(/^\\//)) {\n      // ABSOLUTE PATH\n    } else {\n      // NAMED PATH\n      const matchingRoute = $routes.find(route => route.meta.name === path)\n      if (matchingRoute) path = matchingRoute.shortPath\n    }\n\n    /** @type {Object<string, *>} Parameters */\n    const allParams = Object.assign({}, $oldRoute.params, component.params, params)\n    let pathWithParams = path\n    for (const [key, value] of Object.entries(allParams)) {\n      pathWithParams = pathWithParams.replace(`:${key}`, value)\n    }\n\n    const fullPath = $location.base + pathWithParams + _getQueryString(path, params)\n    return fullPath.replace(/\\?$/, '')\n  }\n}\n\n/**\n * \n * @param {string} path \n * @param {object} params \n */\nfunction _getQueryString(path, params) {\n  if (!config.queryHandler) return \"\"\n  const pathParamKeys = pathToParamKeys(path)\n  const queryParams = {}\n  if (params) Object.entries(params).forEach(([key, value]) => {\n    if (!pathParamKeys.includes(key))\n      queryParams[key] = value\n  })\n  return config.queryHandler.stringify(queryParams)\n}\n\n/**\n* @callback GotoHelper\n* @param {String=} path\n* @param {UrlParams=} params\n* @param {GotoOptions=} options\n*\n* @typedef {import('svelte/store').Readable<GotoHelper>}  GotoHelperStore\n* @type {GotoHelperStore} \n* */\nexport const goto = {\n  subscribe(listener) {\n    return derived(url,\n      url => function goto(path, params, _static, shallow) {\n        const href = url(path, params)\n        if (!_static) history.pushState({}, null, href)\n        else getContext('routifyupdatepage')(href, shallow)\n      }\n    ).subscribe(\n      listener\n    )\n  },\n}\n\n/**\n * @type {GotoHelperStore} \n * */\nexport const redirect = {\n  subscribe(listener) {\n    return derived(url,\n      url => function redirect(path, params, _static, shallow) {\n        const href = url(path, params)\n        if (!_static) history.replaceState({}, null, href)\n        else getContext('routifyupdatepage')(href, shallow)\n      }\n    ).subscribe(\n      listener\n    )\n  },\n}\n\n/**\n * @callback IsActiveHelper\n * @param {String=} path\n * @param {UrlParams=} params\n * @param {UrlOptions=} options\n * @returns {Boolean}\n * \n * @typedef {import('svelte/store').Readable<IsActiveHelper>} IsActiveHelperStore\n * @type {IsActiveHelperStore} \n * */\nexport const isActive = {\n  subscribe(run) {\n    return derived(\n      [url, route],\n      ([url, route]) => function isActive(path = \"\", params = {}, { strict } = { strict: true }) {\n        path = url(path, null, { strict })\n        const currentPath = url(route.path, null, { strict })\n        const re = new RegExp('^' + path + '($|/)')\n        return !!currentPath.match(re)\n      }\n    ).subscribe(run)\n  },\n}\n\n/**\n * @param {string|ClientNodeApi} path \n * @param {*} options \n */\nexport function precache(path, options) {\n  const node = typeof path === 'string' ? urlToRoute(path) : path\n  node.component()\n}\n\n/**\n * @param {string|ClientNodeApi} path \n * @param {*} options \n */\nexport function prefetch(path, options) {\n  _prefetch(path, options)\n}\n\n/**\n * @typedef {[ClientNodeApi, ClientNodeApi, ClientNodeApi]} ConcestorReturn\n * @typedef {function(ClientNodeApi, ClientNodeApi):ConcestorReturn} GetConcestor\n * @type {GetConcestor}\n */\nexport function getConcestor(nodeApi1, nodeApi2) {\n  const node1 = nodeApi1.__file\n  const node2 = nodeApi2.__file\n\n  // The route is the last piece of layout\n  const lineage1 = [...node1.lineage, node1]\n  const lineage2 = [...node2.lineage, node2]\n\n  let concestor = lineage1[0] //root\n  let children = [lineage1[0].api, lineage2[0].api]\n  // iterate through the layouts starting from the root\n  lineage1.forEach((n1, i) => {\n    const n2 = lineage2[i]\n    if (n2 && n1.parent === n2.parent) {\n      concestor = n1.parent\n      children = [n1.api, n2.api]\n    }\n  })\n  return [concestor.api, children[0], children[1]]\n}\n\n/**\n * Get index difference between two paths\n *\n * @export\n * @param {array} paths\n * @param {object} newPath\n * @param {object} oldPath\n * @returns {number}\n */\nexport function getDirection(paths, newPath, oldPath) {\n  const newIndex = paths.findIndex(path => newPath.path.startsWith(path))\n  const oldIndex = paths.findIndex(path => oldPath.path.startsWith(path))\n  return newIndex - oldIndex\n}\n\n/**\n * Sets element to active\n * @typedef {function(HTMLElement):void} FocusHelper\n * @type {FocusHelper}\n */\nexport function focus(element) {\n  if (!focusIsSet) {\n    focusIsSet = true\n    element.setAttribute('tabindex', \"0\")\n    element.focus()\n    setTimeout(() => (focusIsSet = false))\n  }\n}\nlet focusIsSet = false\n\n\n\nconst _metatags = {\n  props: {},\n  templates: {},\n  services: {\n    plain: { propField: 'name', valueField: 'content' },\n    twitter: { propField: 'name', valueField: 'content' },\n    og: { propField: 'property', valueField: 'content' },\n  },\n  plugins: [\n    {\n      name: 'applyTemplate',\n      condition: () => true,\n      action: (prop, value) => {\n        const template = _metatags.getLongest(_metatags.templates, prop) || (x => x)\n        return [prop, template(value)]\n      }\n    },\n    {\n      name: 'createMeta',\n      condition: () => true,\n      action(prop, value) {\n        _metatags.writeMeta(prop, value)\n      }\n    },\n    {\n      name: 'createOG',\n      condition: prop => !prop.match(':'),\n      action(prop, value) {\n        _metatags.writeMeta(`og:${prop}`, value)\n      }\n    },\n    {\n      name: 'createTitle',\n      condition: prop => prop === 'title',\n      action(prop, value) {\n        document.title = value;\n      }\n    }\n  ],\n  getLongest(repo, name) {\n    const providers = repo[name]\n    if (providers) {\n      const currentPath = get(route).path\n      const allPaths = Object.keys(repo[name])\n      const matchingPaths = allPaths.filter(path => currentPath.includes(path))\n\n      const longestKey = matchingPaths.sort((a, b) => b.length - a.length)[0]\n\n      return providers[longestKey]\n    }\n  },\n  writeMeta(prop, value) {\n    const head = document.getElementsByTagName('head')[0]\n    const match = prop.match(/(.+)\\:/)\n    const serviceName = match && match[1] || 'plain'\n    const { propField, valueField } = metatags.services[serviceName] || metatags.services.plain\n    const oldElement = document.querySelector(`meta[${propField}='${prop}']`)\n    if (oldElement) oldElement.remove()\n\n    const newElement = document.createElement('meta')\n    newElement.setAttribute(propField, prop)\n    newElement.setAttribute(valueField, value)\n    newElement.setAttribute('data-origin', 'routify')\n    head.appendChild(newElement)\n  },\n  set(prop, value) {\n    _metatags.plugins.forEach(plugin => {\n      if (plugin.condition(prop, value))\n        [prop, value] = plugin.action(prop, value) || [prop, value]\n    })\n  },\n  clear() {\n    const oldElement = document.querySelector(`meta`)\n    if (oldElement) oldElement.remove()\n  },\n  template(name, fn) {\n    const origin = _metatags.getOrigin()\n    _metatags.templates[name] = _metatags.templates[name] || {}\n    _metatags.templates[name][origin] = fn\n  },\n  update() {\n    Object.keys(_metatags.props).forEach((prop) => {\n      let value = (_metatags.getLongest(_metatags.props, prop))\n      _metatags.plugins.forEach(plugin => {\n        if (plugin.condition(prop, value)) {\n          [prop, value] = plugin.action(prop, value) || [prop, value]\n\n        }\n      })\n    })\n  },\n  batchedUpdate() {\n    if (!_metatags._pendingUpdate) {\n      _metatags._pendingUpdate = true\n      setTimeout(() => {\n        _metatags._pendingUpdate = false\n        this.update()\n      })\n    }\n  },\n  _updateQueued: false,\n  getOrigin() {\n    const routifyCtx = getRoutifyContext()\n    return routifyCtx && get(routifyCtx).path || '/'\n  },\n  _pendingUpdate: false\n}\n\n\n/**\n * metatags\n * @prop {Object.<string, string>}\n */\nexport const metatags = new Proxy(_metatags, {\n  set(target, name, value, receiver) {\n    const { props, getOrigin } = target\n\n    if (Reflect.has(target, name))\n      Reflect.set(target, name, value, receiver)\n    else {\n      props[name] = props[name] || {}\n      props[name][getOrigin()] = value\n    }\n\n    if (window['routify'].appLoaded)\n      target.batchedUpdate()\n    return true\n  }\n})\n\nexport const isChangingPage = (function () {\n  const store = writable(false)\n  beforeUrlChange.subscribe(fn => fn(event => {\n    store.set(true)\n    return true\n  }))\n  \n  afterPageLoad.subscribe(fn => fn(event => store.set(false)))\n\n  return store\n})()"],"names":["getRoutifyContext","getContext","rootContext","afterPageLoad","_hooks","subscribe","hookHandler","beforeUrlChange","listener","hooks","this","index","length","callback","url","[object Object]","ctx","derived","route","routes","location","args","makeUrlHelper","$ctx","$oldRoute","$routes","$location","path","params","options","component","strict","replace","match","breadcrumbs","relativePath","dir","forEach","matchingRoute","find","meta","name","shortPath","allParams","Object","assign","pathWithParams","key","value","entries","base","config","queryHandler","pathParamKeys","pathToParamKeys","queryParams","includes","stringify","_getQueryString","isActive","run","currentPath","re","RegExp","_metatags","props","templates","services","plain","propField","valueField","twitter","og","plugins","condition","action","prop","getLongest","x","writeMeta","document","title","repo","providers","get","keys","filter","sort","a","b","head","getElementsByTagName","serviceName","metatags","oldElement","querySelector","remove","newElement","createElement","setAttribute","appendChild","plugin","fn","origin","getOrigin","_pendingUpdate","setTimeout","update","_updateQueued","routifyCtx","Proxy","target","receiver","Reflect","has","set","window","appLoaded","batchedUpdate","isChangingPage","store","writable","event"],"mappings":"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"}