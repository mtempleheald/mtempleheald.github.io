{"version":3,"file":"navigator.js","sources":["../../../../../../node_modules/@sveltech/routify/runtime/navigator.js"],"sourcesContent":["import * as stores from './store'\nimport { get } from 'svelte/store'\nimport { beforeUrlChange } from './helpers'\nimport { urlToRoute } from './utils/urlToRoute'\nimport { currentLocation } from './utils'\n\nexport function init(routes, callback) {\n  /** @type { ClientNode | false } */\n  let lastRoute = false\n\n  function updatePage(proxyToUrl, shallow) {\n    const url = proxyToUrl || currentLocation()\n    const route = urlToRoute(url, routes)\n    const currentRoute = shallow && urlToRoute(currentLocation(), routes)\n    const contextRoute = currentRoute || route\n    const layouts = [...contextRoute.layouts, route]\n    if (lastRoute) delete lastRoute.last //todo is a page component the right place for the previous route?\n    route.last = lastRoute\n    lastRoute = route\n\n    //set the route in the store\n    if (!proxyToUrl)\n      stores.urlRoute.set(route)\n    stores.route.set(route)\n\n    //run callback in Router.svelte\n    callback(layouts)\n  }\n\n  const destroy = createEventListeners(updatePage)\n\n  return { updatePage, destroy }\n}\n\n/**\n * svelte:window events doesn't work on refresh\n * @param {Function} updatePage\n */\nfunction createEventListeners(updatePage) {\n  // history.*state\n  ;['pushState', 'replaceState'].forEach(eventName => {\n    const fn = history[eventName]\n    history[eventName] = async function (state = {}, title, url) {\n      const { id, path, params } = get(stores.route)\n      state = { id, path, params, ...state }\n      const event = new Event(eventName.toLowerCase())\n      Object.assign(event, { state, title, url })\n\n      if (await runHooksBeforeUrlChange(event)) {\n        fn.apply(this, [state, title, url])\n        return dispatchEvent(event)\n      }\n    }\n  })\n\n  let _ignoreNextPop = false\n\n  const listeners = {\n    click: handleClick,\n    pushstate: () => updatePage(),\n    replacestate: () => updatePage(),\n    popstate: async event => {\n      if (_ignoreNextPop)\n        _ignoreNextPop = false\n      else {\n        if (await runHooksBeforeUrlChange(event)) {\n          updatePage()\n        } else {\n          _ignoreNextPop = true\n          event.preventDefault()\n          history.go(1)\n        }\n      }\n    },\n  }\n\n  Object.entries(listeners).forEach(args => addEventListener(...args))\n\n  const unregister = () => {\n    Object.entries(listeners).forEach(args => removeEventListener(...args))\n  }\n\n  return unregister\n}\n\nfunction handleClick(event) {\n  const el = event.target.closest('a')\n  const href = el && el.getAttribute('href')\n\n  if (\n    event.ctrlKey ||\n    event.metaKey ||\n    event.altKey ||\n    event.shiftKey ||\n    event.button ||\n    event.defaultPrevented\n  )\n    return\n  if (!href || el.target || el.host !== location.host) return\n\n  event.preventDefault()\n  history.pushState({}, '', href)\n}\n\nasync function runHooksBeforeUrlChange(event) {\n  const route = get(stores.route)\n  for (const hook of beforeUrlChange._hooks.filter(Boolean)) {\n    // return false if the hook returns false\n    const result = await hook(event, route) //todo remove route from hook. Its API Can be accessed as $page\n    if (!result) return false\n  }\n  return true\n}\n\n"],"names":["init","routes","callback","lastRoute","updatePage","proxyToUrl","shallow","url","currentLocation","route","urlToRoute","layouts","last","stores.urlRoute","set","stores.route","destroy","forEach","eventName","fn","history","async","state","title","id","path","params","get","event","Event","toLowerCase","Object","assign","runHooksBeforeUrlChange","apply","this","dispatchEvent","_ignoreNextPop","listeners","click","handleClick","pushstate","replacestate","popstate","preventDefault","go","entries","args","addEventListener","removeEventListener","createEventListeners","el","target","closest","href","getAttribute","ctrlKey","metaKey","altKey","shiftKey","button","defaultPrevented","host","location","pushState","hook","beforeUrlChange","_hooks","filter","Boolean"],"mappings":"8QAMO,SAASA,EAAKC,EAAQC,GAE3B,IAAIC,GAAY,EAEhB,SAASC,EAAWC,EAAYC,GAC9B,MAAMC,EAAMF,GAAcG,IACpBC,EAAQC,EAAWH,GAGnBI,EAAU,KAFKL,GAAWI,EAAWF,MACNC,GACJE,QAASF,GACtCN,UAAkBA,EAAUS,KAChCH,EAAMG,KAAOT,EACbA,EAAYM,EAGPJ,GACHQ,EAAgBC,IAAIL,GACtBM,EAAaD,IAAIL,GAGjBP,EAASS,GAGX,MAAMK,EASR,SAA8BZ,GAE3B,CAAC,YAAa,gBAAgBa,SAAQC,IACrC,MAAMC,EAAKC,QAAQF,GACnBE,QAAQF,GAAaG,eAAgBC,EAAQ,GAAIC,EAAOhB,GACtD,MAAMiB,GAAEA,EAAEC,KAAEA,EAAIC,OAAEA,GAAWC,EAAIZ,GACjCO,EAAQ,CAAEE,GAAAA,EAAIC,KAAAA,EAAMC,OAAAA,KAAWJ,GAC/B,MAAMM,EAAQ,IAAIC,MAAMX,EAAUY,eAGlC,GAFAC,OAAOC,OAAOJ,EAAO,CAAEN,MAAAA,EAAOC,MAAAA,EAAOhB,IAAAA,UAE3B0B,EAAwBL,GAEhC,OADAT,EAAGe,MAAMC,KAAM,CAACb,EAAOC,EAAOhB,IACvB6B,cAAcR,OAK3B,IAAIS,GAAiB,EAErB,MAAMC,EAAY,CAChBC,MAAOC,EACPC,UAAW,IAAMrC,IACjBsC,aAAc,IAAMtC,IACpBuC,SAAUtB,MAAAA,IACJgB,EACFA,GAAiB,QAEPJ,EAAwBL,GAChCxB,KAEAiC,GAAiB,EACjBT,EAAMgB,iBACNxB,QAAQyB,GAAG,MAMnBd,OAAOe,QAAQR,GAAWrB,SAAQ8B,GAAQC,oBAAoBD,KAM9D,MAJmB,KACjBhB,OAAOe,QAAQR,GAAWrB,SAAQ8B,GAAQE,uBAAuBF,MAlDnDG,CAAqB9C,GAErC,MAAO,CAAEA,WAAAA,EAAYY,QAAAA,GAsDvB,SAASwB,EAAYZ,GACnB,MAAMuB,EAAKvB,EAAMwB,OAAOC,QAAQ,KAC1BC,EAAOH,GAAMA,EAAGI,aAAa,QAGjC3B,EAAM4B,SACN5B,EAAM6B,SACN7B,EAAM8B,QACN9B,EAAM+B,UACN/B,EAAMgC,QACNhC,EAAMiC,kBAGHP,IAAQH,EAAGC,QAAUD,EAAGW,OAASC,SAASD,OAE/ClC,EAAMgB,iBACNxB,QAAQ4C,UAAU,GAAI,GAAIV,IAG5BjC,eAAeY,EAAwBL,GACrC,MAAMnB,EAAQkB,EAAIZ,GAClB,IAAK,MAAMkD,KAAQC,EAAgBC,OAAOC,OAAOC,SAAU,CAGzD,UADqBJ,EAAKrC,EAAOnB,GACpB,OAAO,EAEtB,OAAO"}