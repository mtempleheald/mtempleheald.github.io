import{S as Nc,i as jc,s as Hc,k as a,q as t,a as n,l as s,m as r,r as o,h as i,c,n as h,b as d,I as e,C as on}from"../chunks/index.de0bb5b5.js";function Gc(Rc){let X,Wo,uo,j,No,jo,Ho,Go,Vo,ho,Oe,Uo,fo,k,Z,rt,Ko,Yo,Jo,zo,$o,H,nt,Xo,Zo,ei,ti,oi,ii,ai,ee,ct,si,li,ri,ni,ci,T,ut,ui,di,hi,fi,ue,pi,mi,de,bi,gi,vi,Pe,dt,yi,wi,po,Me,Ei,mo,Qe,_i,bo,q,qi,he,Ii,Si,fe,Di,ki,pe,Li,Ci,me,Ti,xi,Ri,Bi,go,x,ht,Ai,Fi,ft,Oi,Pi,pt,Mi,Qi,mt,Wi,vo,We,Ni,yo,te,ji,Hi,Gi,wo,I,bt,Vi,Ui,Ne,be,Ki,Yi,Ji,je,ge,zi,$i,Xi,He,ve,Zi,ea,ta,Ge,ye,oa,ia,aa,Ve,we,sa,la,Eo,G,ra,Ee,na,ca,_e,ua,da,_o,Ue,ha,qo,R,fa,qe,pa,ma,ba,ga,va,ya,Io,Ke,wa,So,Ye,Ea,Do,f,gt,_a,qa,oe,Ia,Sa,Da,vt,ka,La,Je,Ca,yt,Ta,xa,wt,Ra,Ba,Ie,Aa,Et,Fa,Oa,Pa,g,Ma,Qa,Wa,Se,Na,ja,Ha,Ga,_t,Va,Ua,qt,Ka,Ya,It,Ja,za,St,$a,Xa,Za,es,ts,y,os,is,as,Dt,ss,ls,rs,ns,De,cs,us,ds,hs,fs,kt,ps,ms,bs,_,gs,Lt,vs,ys,ze,Bc=`<code class="language-undefined">classpath: /liquibase/changelog
changeLogFile: changelog.xml
url: jdbc:sqlserver://localhost:1433;database=master;encrypt=true;trustServerCertificate=true
username: sa
password: yourStrong(!)Password
# liquibaseProLicenseKey=&lt;PASTE LB PRO LICENSE KEY HERE&gt;</code>`,ws,ke,Es,_s,Le,qs,Is,Ss,Ds,Ct,ks,Ls,Cs,p,Ts,xs,Rs,Tt,Bs,As,Fs,xt,Os,Ps,Ms,Qs,Rt,Ws,Ns,js,Hs,Bt,Gs,Vs,Us,Ks,At,Ys,Js,zs,$s,Ft,Xs,Zs,el,v,tl,ol,il,Ot,al,sl,ll,Pt,rl,nl,cl,Mt,ul,dl,Qt,hl,fl,pl,Wt,ml,bl,gl,vl,V,yl,wl,El,Nt,_l,ql,Il,Sl,jt,Dl,ko,$e,kl,Lo,B,Ce,Y,Ll,Ht,Cl,Tl,Gt,xl,Rl,Bl,Xe,Ac=`<code class="language-c#">public class ConnectionStringsOptions
&#123;
   public const string ConfigKey = &quot;ConnectionStrings&quot;;
   public string MyDb &#123; get; set; &#125; = string.Empty;
&#125;</code>`,Al,Te,Q,Fl,Vt,Ol,Pl,Ut,Ml,Ql,Wl,Nl,jl,C,xe,Hl,Kt,Gl,Vl,Ul,Yt,Kl,Yl,Re,Jl,Jt,zl,$l,Xl,zt,Zl,er,$t,tr,or,J,W,ir,Xt,ar,sr,Zt,lr,rr,nr,cr,ur,N,eo,dr,hr,to,fr,pr,oo,mr,br,io,gr,vr,Ze,Fc=`<code class="language-c#">public TestWebApplicationFactory(MsSqlTestFixture sqlTestFixture)
&#123;
 _connectionString = $&quot;Server=&#123;sqlTestFixture._msSqlcontainer.Hostname
     &#125;,&#123;sqlTestFixture._msSqlcontainer.GetMappedPublicPort(MsSqlTestFixture.MsSqlPort)
     &#125;;Database=&#123;MsSqlTestFixture.Database
     &#125;;User Id=&#123;MsSqlTestFixture.Username
     &#125;;Password=&#123;MsSqlTestFixture.Password
     &#125;;TrustServerCertificate=True&quot;;
&#125;

protected override IHost CreateHost(IHostBuilder builder)
&#123;
   builder.ConfigureServices(services =&gt; 
   &#123;
      services.Configure&lt;ConnectionStringsOptions&gt;(opts =&gt; &#123;
      opts.MyDb = _connectionString;
      &#125;);
   &#125;);
&#125;</code>`,yr,Be,A,wr,ao,Er,_r,so,qr,Ir,lo,Sr,Dr,kr,Lr,et,Oc=`<code class="language-c#">public MsSqlTests(MsSqlTestFixture msSqlTestFixture)
&#123;
   _webApplicationFactory = new TestWebApplicationFactory&lt;Program&gt;(msSqlTestFixture);
   _httpClient = _webApplicationFactory.CreateClient(new WebApplicationFactoryClientOptions &#123;
     AllowAutoRedirect = false // Test first response
   &#125;);
&#125;
public void Dispose()
&#123;
   _webApplicationFactory.Dispose();
&#125;</code>`,Co,tt,Cr,To,S,Tr,xr,Rr,Br,Ar,Fr,Or,Pr,Mr,Qr,Wr,xo,ot,Nr,Ro,F,jr,Hr,Gr,Vr,Ur,Kr,Yr;return{c(){X=a("h1"),Wo=t("Publish Database from ERD"),uo=n(),j=a("p"),No=t("I’m focusing here only on a relational database, typically a suitable choice for my use cases."),jo=a("br"),Ho=t(`
I often find that blogs/tutorials/demos always skip over the data aspect of solutions.`),Go=a("br"),Vo=t(`
In my experience managing code is easy, managing data is hard.  Unless your data is transient in nature database changes require careful thought.`),ho=n(),Oe=a("p"),Uo=t("My key requirements in an effective data design strategy are:"),fo=n(),k=a("ol"),Z=a("li"),rt=a("strong"),Ko=t("Visualisation"),Yo=t(" - I want to see an ERD or something similar, without this understanding a non-trivial database is going to be hard."),Jo=a("br"),zo=t(`
This needs to be versioned with the code, which rules out Visio and other binary representations.`),$o=n(),H=a("li"),nt=a("strong"),Xo=t("Automation"),Zo=t(" - The ERD and the production database should be linked via automated means."),ei=a("br"),ti=t(`
Out-of-date documentation is sometimes worse than no documentation at all.`),oi=a("br"),ii=t(`
This rules out EF Core migrations (even if not using EF Core for production code).`),ai=n(),ee=a("li"),ct=a("strong"),si=t("Testability"),li=t(" - Not so much a feature of the database, but I need to know that DB changes do not break things."),ri=a("br"),ni=t(`
This means that integration tests must use the real database, on the same version as production, also during local dev, which leads me towards Docker.`),ci=n(),T=a("li"),ut=a("strong"),ui=t("Provider-agnostic"),di=t(" - I have seen what vendor lock-in leads to and I don’t like it, we must maintain control of our applications."),hi=a("br"),fi=t(`
In reality it is impossible to avoid this completely, but simple things like adhering to `),ue=a("a"),pi=t("SQL Standards"),mi=t(` can help reduce the impact of migration.  I only want tables, indexes, constraints and possibly views, all logic will be in the application code.
This requirement rules out SSDT and `),de=a("a"),bi=t("DACPAC"),gi=t(" deployment which is great, but only for SQL Server."),vi=n(),Pe=a("li"),dt=a("strong"),yi=t("Maintainability"),wi=t(" - the solution needs to be simple to use in the medium to long term, though not necessarily simple to set up."),po=n(),Me=a("p"),Ei=t("This mini project is something I’ve been meaning to do for years, since I built an Oracle DB deployment tool in Go and subsequently discovered DACPAC deployment in SQL Server."),mo=n(),Qe=a("h2"),_i=t("Visualisation"),bo=n(),q=a("p"),qi=t("I considered various options, including Microsoft Visio, "),he=a("a"),Ii=t("Mermaid"),Si=t(", "),fe=a("a"),Di=t("dbdiagram.io"),ki=t(", "),pe=a("a"),Li=t("Structurizr"),Ci=t(" to generate Mermaid diagrams, but eventually settled on "),me=a("a"),Ti=t("ERD Editor"),xi=t(" for VS Code."),Ri=a("br"),Bi=t(`
I came to this decision because:`),go=n(),x=a("ul"),ht=a("li"),Ai=t("It is free & open source, so even if it was taken offline and destroyed I could invest some time and recover to my forked version"),Fi=n(),ft=a("li"),Oi=t("It is offline, meaning that any sensitive data models are kept secure"),Pi=n(),pt=a("li"),Mi=t("It is stored in text/json format, not binary, which makes version control in git tenable"),Qi=n(),mt=a("li"),Wi=t("It has a feature to output liquibase changelogs built in"),vo=n(),We=a("h2"),Ni=t("Automation"),yo=n(),te=a("p"),ji=t("Most DB automation tools are either prohibitively expensive, or vendor-specific."),Hi=a("br"),Gi=t(`
I considered various options for automation, including:`),wo=n(),I=a("ul"),bt=a("li"),Vi=t("Enhancing my old Go based solution for Oracle DBs, but I don’t have the code, only the design principles, so effectively this would be a fresh start."),Ui=n(),Ne=a("li"),be=a("a"),Ki=t("SSDT (DACPAC publish)"),Yi=t(", but this is SQL Server specific."),Ji=n(),je=a("li"),ge=a("a"),zi=t("EF Migrations"),$i=t(", but this doesn’t work with visualisation tools AFAIK and I don’t want to be tied to EF Core, since it is .NET only."),Xi=n(),He=a("li"),ve=a("a"),Zi=t("Redgate Tools"),ea=t(" but I assume this is too expensive since they don’t list the price on their website."),ta=n(),Ge=a("li"),ye=a("a"),oa=t("Fluent Migrator"),ia=t(" but again this is .NET-specific, I don’t see a benefit over EF Core."),aa=n(),Ve=a("li"),we=a("a"),sa=t("Roundhouse"),la=t(" but again this is .NET-specific, it also seems to be poorly maintained although I do like the convention-over-configuration approach at a glance"),Eo=n(),G=a("p"),ra=t("I eventually settled on "),Ee=a("a"),na=t("Liquibase"),ca=t(" because it has a free and open source option (Apache-2.0 licensed), supports Docker, is clearly built to support CI/CD with documented "),_e=a("a"),ua=t("Open Source Workflows"),da=t(" and, crucially, it works with the visualisation tool I’ve selected."),_o=n(),Ue=a("h2"),ha=t("Testability"),qo=n(),R=a("p"),fa=t("The prompt for this mini-project was the discovery of "),qe=a("a"),pa=t("Testcontainers"),ma=t(" (via Nick Chapsas on Youtube)."),ba=a("br"),ga=t(`
This allows you to spin up a throwaway docker container, or collection of, just for the lifetime of the test(s).`),va=a("br"),ya=t(`
This is not a substitute for unit testing since it will be significantly slower, but it is a better solution than testing with in-memory databases, which may have subtle differences in behaviour to the production database.`),Io=n(),Ke=a("h2"),wa=t("The solution"),So=n(),Ye=a("h3"),Ea=t("Initial setup"),Do=n(),f=a("ol"),gt=a("li"),_a=t("Install Docker (and optionally Docker Desktop, if licencing allows), examples below are unix images on Windows."),qa=n(),oe=a("li"),Ia=t("Run SQL instance (example is MSSQL) for any manual testing and to prove scripts"),Sa=a("br"),Da=n(),vt=a("code"),ka=t('docker run --name "mssql_manual_test" -e "ACCEPT_EULA=Y" -e "MSSQL_SA_PASSWORD=yourStrong(!)Password" -p 1433:1433 -d mcr.microsoft.com/mssql/server:2022-latest'),La=n(),Je=a("li"),Ca=t("Get latest liquibase image "),yt=a("code"),Ta=t("docker pull liquibase/liquibase"),xa=n(),wt=a("li"),Ra=t("Install VS Code extension “ERD Editor” (vuerd)"),Ba=n(),Ie=a("li"),Aa=t("Create an ERD file "),Et=a("code"),Fa=t("<name>.vuerd.json"),Oa=t(" within the project/solution/workspace, open this in VS Code and it should automatically load the editor."),Pa=n(),g=a("li"),Ma=t("Create a DB model, be sure not to deselect Postgres as the output regardless of target DB type, required for Liquibase support"),Qa=a("br"),Wa=t(`
Be careful here to use appropriate data types for the target environment, `),Se=a("a"),Na=t("ERD Editor supported types"),ja=t("."),Ha=a("br"),Ga=t(`
The tool is clever enough to convert from `),_t=a("code"),Va=t("uuid"),Ua=t(" to "),qt=a("code"),Ka=t("uniqueidentifier"),Ya=t(", but not clever enough to convert from "),It=a("code"),Ja=t("varchar"),za=t(" to "),St=a("code"),$a=t("varchar2"),Xa=t(" for example and certainly not when lengths are included (which they need to be since the default is 1 character)."),Za=a("br"),es=t(`
Effectively I’d advise making multiple DB models if supporting multiple DB providers, but decide which is master, copy/paste, find/replace in JSON files to keep multiple versions in sync and versioned together (this is why models should be stored in text format).`),ts=n(),y=a("li"),os=t("Generate a Liquibase changeset by right clicking the model and selecting Export > Liquibase"),is=a("br"),as=t(`
Use the naming convention `),Dt=a("em"),ss=t("liquibase-change-###"),ls=t(", 999 DB changes should be enough for most projects."),rs=a("br"),ns=t(`
Liquibase uses the id, author and filename to track changes - `),De=a("a"),cs=t("How Liquibase works"),us=a("br"),ds=t(`
Keep the changelogs alongside the ERD model in source code, this lets ERD Editor load older changelogs to guarantee correct generation of new changelogs.`),hs=a("br"),fs=t(`
To apply multiple chainsets automatically, which we will need for automation, it is necessary to manually configure a master changelog `),kt=a("code"),ps=t("liquibase-change.xml"),ms=t("."),bs=n(),_=a("li"),gs=t("Configure liquibase using a "),Lt=a("em"),vs=t("liquibase.properties"),ys=t(" file in the same folder:  "),ze=a("pre"),ws=t("This example is using the defaults for a "),ke=a("a"),Es=t("SQL Server docker"),_s=t(" container, although the "),Le=a("a"),qs=t("Liquibase recommendation"),Is=t(" is to pass these as arguments.  Passing by argument is also required for running multiple test sets in parallel since only one Docker container at a time can respond on a given port, even if we reuse credentials for testing, so this defaultsFile is kept just to simplify any manual test processes locally."),Ss=a("br"),Ds=t(`
We require `),Ct=a("code"),ks=t("encrypt=true and trustServerCertificate=true"),Ls=t(" to resolve firewall and SSL errors respectively, encountered whilst applying test changeset."),Cs=n(),p=a("li"),Ts=t("We can now run liquibase commands, e.g. help"),xs=a("br"),Rs=n(),Tt=a("code"),Bs=t('docker run --rm --net=host -v "C:\\Path\\To\\Folder\\Containing\\changelogs":/liquibase/changelog liquibase/liquibase --defaultsFile=/liquibase/changelog/liquibase.properties --help'),As=a("br"),Fs=n(),xt=a("code"),Os=t("--rm"),Ps=t(" ensures that the docker container is removed after completion of the script (see debugging)"),Ms=a("br"),Qs=n(),Rt=a("code"),Ws=t("-net=host"),Ns=t(" ensures that the liquibase container can talk outside of the Docker bridge network (e.g. to connect to a Docker hosted DB).  In hindsight it is better to use internal network alias on the SQL container to connect from liquibase."),js=a("br"),Hs=n(),Bt=a("code"),Gs=t("-v"),Vs=t(" maps our local folder (Windows in this example) to the root of Liquibase’s changelog tree volume."),Us=a("br"),Ks=n(),At=a("code"),Ys=t("--defaultsFile"),Js=t(" tells Liquibase to use our properties file, which in turn tells it where to find changelogs and how to connect to the DB."),zs=a("br"),$s=n(),Ft=a("code"),Xs=t("--help"),Zs=t(" tells Liquibase to show us its help documentation, including available commands"),el=n(),v=a("li"),tl=t("Debugging - if any of our commands fail we can investigate by launching Liquibase with a built-in in-memory DB:"),ol=a("br"),il=n(),Ot=a("code"),al=t('docker run --net=host -v "C:\\Path\\To\\Folder\\Containing\\changelogs":/liquibase/changelog liquibase/liquibase --defaultsFile=/liquibase/changelog/liquibase.properties init start-h2'),sl=a("br"),ll=t(`
In a separate command window find the running container using `),Pt=a("code"),rl=t("docker ps"),nl=a("br"),cl=t(`
Jump inside it using `),Mt=a("code"),ul=t("docker exec -it <container_id> bash"),dl=t(", you should see your files within "),Qt=a("code"),hl=t("/changelog"),fl=a("br"),pl=t(`
From here you can run the same commands (everything after liquibase/liquibase) on top of liquibase directly, e.g. `),Wt=a("code"),ml=t("liquibase --help"),bl=a("br"),gl=t(`
When done you will need to stop and remove the docker container yourself.`),vl=n(),V=a("li"),yl=t("Apply the changeset to the database manually (dbo schema is default for SQL Server)"),wl=a("br"),El=n(),Nt=a("code"),_l=t('docker run --rm --net=host -v "C:\\Path\\To\\Folder\\Containing\\changelogs":/liquibase/changelog liquibase/liquibase --defaultsFile=/liquibase/changelog/liquibase.properties update --changelog-file=liquibase-change-001.xml --default-schema-name=dbo'),ql=a("br"),Il=t(`
If a changeset fails in dev, perhaps due to messing up constraints :|, and you wish to keep changesets clean before commit, you can truncate the table DATABASECHANGELOG which Liquibase manages.`),Sl=n(),jt=a("li"),Dl=t("Check that this has worked as expected using SQL Server Object Explorer in Visual Studio or SQL browser of preference."),ko=n(),$e=a("h3"),kl=t("Code changes"),Lo=n(),B=a("ol"),Ce=a("li"),Y=a("p"),Ll=t("Ensure that any DB code (repository) accesses the connection string via "),Ht=a("code"),Cl=t("IOptions"),Tl=t(" or better yet "),Gt=a("code"),xl=t("IOptionsSnapshot"),Rl=t(" to allow live reloading of config."),Bl=n(),Xe=a("pre"),Al=n(),Te=a("li"),Q=a("p"),Fl=t("Create an xUnit IClassFixture "),Vt=a("code"),Ol=t("MsSqlTestFixture"),Pl=t(", implementing "),Ut=a("code"),Ml=t("IAsyncLifetime"),Ql=t(" to ensure that it runs once per test class which uses it."),Wl=a("br"),Nl=t(`
This class will:`),jl=n(),C=a("ol"),xe=a("li"),Hl=t("Create a SQL container using the "),Kt=a("code"),Gl=t("ContainerBuilder"),Vl=t(", mirroring the parameters above, although with a dynamically generated port."),Ul=n(),Yt=a("li"),Kl=t("Wait for this to become responsive (by which I mean can accept SQL commands not just commands at the Docker/network layer)"),Yl=n(),Re=a("li"),Jl=t("Spin up a Liquibase container to run a single command on this transient database - "),Jt=a("code"),zl=t("update"),$l=t(", to apply all changes to get to the current version from an empty database and dispose it after completion."),Xl=n(),zt=a("li"),Zl=t("Expose SQL connection details via internal constants, for use by the test application."),er=n(),$t=a("li"),tr=t("Dispose the SQL container and associated classes after test execution."),or=n(),J=a("li"),W=a("p"),ir=t("Create a custom "),Xt=a("code"),ar=t("WebApplicationFactory"),sr=t(" for testing, e.g. "),Zt=a("code"),lr=t("TestWebApplicationFactory"),rr=t("."),nr=a("br"),cr=t(`
This class will:`),ur=n(),N=a("ol"),eo=a("li"),dr=t("Start with the WebApplicationFactory used by the application itself."),hr=n(),to=a("li"),fr=t("Replace real external dependencies in favour of managed stubs/fakes (out of scope of this document)."),pr=n(),oo=a("li"),mr=t("Use constructor injection to load the SQL TestFixture which exposes the connection details of the transient database."),br=n(),io=a("li"),gr=t("Replace real connection strings with a connection string built from the SQL container settings."),vr=n(),Ze=a("pre"),yr=n(),Be=a("li"),A=a("p"),wr=t("Create a test class "),ao=a("code"),Er=t("MsSqlTests"),_r=t(" which inherits "),so=a("code"),qr=t("IClassFixture<MsSqlTestFixture>"),Ir=t(" and "),lo=a("code"),Sr=t("IDisposable"),Dr=a("br"),kr=t(`
In the constructor use the above classes to make the DB available to the tests:`),Lr=n(),et=a("pre"),Co=n(),tt=a("h3"),Cr=t("Issues"),To=n(),S=a("p"),Tr=t("It takes some time to spin up a liquibase container, connect to a SQL database and apply migration scripts."),xr=a("br"),Rr=t(`
I found during exploration that whilst debugging the test everything was working as designed, however, whilst running the tests had completed (with failures) before the DB scripts had been executed.`),Br=a("br"),Ar=t(`
It is possible to set a WaitStrategy on testcontainers to ensure that they are ready before moving on.`),Fr=a("br"),Or=t(`
I had no luck getting this to work with liquibase, since it is not designed to stay up after the command is completed.`),Pr=a("br"),Mr=t(`
I’m sure there’s a better way, but my fix for this was to put a while loop in between starting and disposing the liquibase container.`),Qr=a("br"),Wr=t(`
This simply runs an appropriate query on the SQL container which indicates completion, then waits for a second before retrying, up to N times.`),xo=n(),ot=a("h3"),Nr=t("Next steps"),Ro=n(),F=a("p"),jr=t("The solution now works as intended (as long as you remember to start Docker first)."),Hr=a("br"),Gr=t(`
I simply need to complete the work now, in a more test driven fashion than I normally would.`),Vr=a("br"),Ur=t(`
Finally I need to automate integration testing on CICD pipelines.`),Kr=a("br"),Yr=t(`
All of the above is checked in to a private GitHub repo for now, I may make this public at some point.`),this.h()},l(l){X=s(l,"H1",{});var u=r(X);Wo=o(u,"Publish Database from ERD"),u.forEach(i),uo=c(l),j=s(l,"P",{});var it=r(j);No=o(it,"I’m focusing here only on a relational database, typically a suitable choice for my use cases."),jo=s(it,"BR",{}),Ho=o(it,`
I often find that blogs/tutorials/demos always skip over the data aspect of solutions.`),Go=s(it,"BR",{}),Vo=o(it,`
In my experience managing code is easy, managing data is hard.  Unless your data is transient in nature database changes require careful thought.`),it.forEach(i),ho=c(l),Oe=s(l,"P",{});var an=r(Oe);Uo=o(an,"My key requirements in an effective data design strategy are:"),an.forEach(i),fo=c(l),k=s(l,"OL",{});var U=r(k);Z=s(U,"LI",{});var ro=r(Z);rt=s(ro,"STRONG",{});var sn=r(rt);Ko=o(sn,"Visualisation"),sn.forEach(i),Yo=o(ro," - I want to see an ERD or something similar, without this understanding a non-trivial database is going to be hard."),Jo=s(ro,"BR",{}),zo=o(ro,`
This needs to be versioned with the code, which rules out Visio and other binary representations.`),ro.forEach(i),$o=c(U),H=s(U,"LI",{});var Ae=r(H);nt=s(Ae,"STRONG",{});var ln=r(nt);Xo=o(ln,"Automation"),ln.forEach(i),Zo=o(Ae," - The ERD and the production database should be linked via automated means."),ei=s(Ae,"BR",{}),ti=o(Ae,`
Out-of-date documentation is sometimes worse than no documentation at all.`),oi=s(Ae,"BR",{}),ii=o(Ae,`
This rules out EF Core migrations (even if not using EF Core for production code).`),Ae.forEach(i),ai=c(U),ee=s(U,"LI",{});var no=r(ee);ct=s(no,"STRONG",{});var rn=r(ct);si=o(rn,"Testability"),rn.forEach(i),li=o(no," - Not so much a feature of the database, but I need to know that DB changes do not break things."),ri=s(no,"BR",{}),ni=o(no,`
This means that integration tests must use the real database, on the same version as production, also during local dev, which leads me towards Docker.`),no.forEach(i),ci=c(U),T=s(U,"LI",{});var z=r(T);ut=s(z,"STRONG",{});var nn=r(ut);ui=o(nn,"Provider-agnostic"),nn.forEach(i),di=o(z," - I have seen what vendor lock-in leads to and I don’t like it, we must maintain control of our applications."),hi=s(z,"BR",{}),fi=o(z,`
In reality it is impossible to avoid this completely, but simple things like adhering to `),ue=s(z,"A",{href:!0,rel:!0});var cn=r(ue);pi=o(cn,"SQL Standards"),cn.forEach(i),mi=o(z,` can help reduce the impact of migration.  I only want tables, indexes, constraints and possibly views, all logic will be in the application code.
This requirement rules out SSDT and `),de=s(z,"A",{href:!0,rel:!0});var un=r(de);bi=o(un,"DACPAC"),un.forEach(i),gi=o(z," deployment which is great, but only for SQL Server."),z.forEach(i),vi=c(U),Pe=s(U,"LI",{});var Jr=r(Pe);dt=s(Jr,"STRONG",{});var dn=r(dt);yi=o(dn,"Maintainability"),dn.forEach(i),wi=o(Jr," - the solution needs to be simple to use in the medium to long term, though not necessarily simple to set up."),Jr.forEach(i),U.forEach(i),po=c(l),Me=s(l,"P",{});var hn=r(Me);Ei=o(hn,"This mini project is something I’ve been meaning to do for years, since I built an Oracle DB deployment tool in Go and subsequently discovered DACPAC deployment in SQL Server."),hn.forEach(i),mo=c(l),Qe=s(l,"H2",{});var fn=r(Qe);_i=o(fn,"Visualisation"),fn.forEach(i),bo=c(l),q=s(l,"P",{});var O=r(q);qi=o(O,"I considered various options, including Microsoft Visio, "),he=s(O,"A",{href:!0,rel:!0});var pn=r(he);Ii=o(pn,"Mermaid"),pn.forEach(i),Si=o(O,", "),fe=s(O,"A",{href:!0,rel:!0});var mn=r(fe);Di=o(mn,"dbdiagram.io"),mn.forEach(i),ki=o(O,", "),pe=s(O,"A",{href:!0,rel:!0});var bn=r(pe);Li=o(bn,"Structurizr"),bn.forEach(i),Ci=o(O," to generate Mermaid diagrams, but eventually settled on "),me=s(O,"A",{href:!0,rel:!0});var gn=r(me);Ti=o(gn,"ERD Editor"),gn.forEach(i),xi=o(O," for VS Code."),Ri=s(O,"BR",{}),Bi=o(O,`
I came to this decision because:`),O.forEach(i),go=c(l),x=s(l,"UL",{});var ie=r(x);ht=s(ie,"LI",{});var vn=r(ht);Ai=o(vn,"It is free & open source, so even if it was taken offline and destroyed I could invest some time and recover to my forked version"),vn.forEach(i),Fi=c(ie),ft=s(ie,"LI",{});var yn=r(ft);Oi=o(yn,"It is offline, meaning that any sensitive data models are kept secure"),yn.forEach(i),Pi=c(ie),pt=s(ie,"LI",{});var wn=r(pt);Mi=o(wn,"It is stored in text/json format, not binary, which makes version control in git tenable"),wn.forEach(i),Qi=c(ie),mt=s(ie,"LI",{});var En=r(mt);Wi=o(En,"It has a feature to output liquibase changelogs built in"),En.forEach(i),ie.forEach(i),vo=c(l),We=s(l,"H2",{});var _n=r(We);Ni=o(_n,"Automation"),_n.forEach(i),yo=c(l),te=s(l,"P",{});var Bo=r(te);ji=o(Bo,"Most DB automation tools are either prohibitively expensive, or vendor-specific."),Hi=s(Bo,"BR",{}),Gi=o(Bo,`
I considered various options for automation, including:`),Bo.forEach(i),wo=c(l),I=s(l,"UL",{});var P=r(I);bt=s(P,"LI",{});var qn=r(bt);Vi=o(qn,"Enhancing my old Go based solution for Oracle DBs, but I don’t have the code, only the design principles, so effectively this would be a fresh start."),qn.forEach(i),Ui=c(P),Ne=s(P,"LI",{});var zr=r(Ne);be=s(zr,"A",{href:!0,rel:!0});var In=r(be);Ki=o(In,"SSDT (DACPAC publish)"),In.forEach(i),Yi=o(zr,", but this is SQL Server specific."),zr.forEach(i),Ji=c(P),je=s(P,"LI",{});var $r=r(je);ge=s($r,"A",{href:!0,rel:!0});var Sn=r(ge);zi=o(Sn,"EF Migrations"),Sn.forEach(i),$i=o($r,", but this doesn’t work with visualisation tools AFAIK and I don’t want to be tied to EF Core, since it is .NET only."),$r.forEach(i),Xi=c(P),He=s(P,"LI",{});var Xr=r(He);ve=s(Xr,"A",{href:!0,rel:!0});var Dn=r(ve);Zi=o(Dn,"Redgate Tools"),Dn.forEach(i),ea=o(Xr," but I assume this is too expensive since they don’t list the price on their website."),Xr.forEach(i),ta=c(P),Ge=s(P,"LI",{});var Zr=r(Ge);ye=s(Zr,"A",{href:!0,rel:!0});var kn=r(ye);oa=o(kn,"Fluent Migrator"),kn.forEach(i),ia=o(Zr," but again this is .NET-specific, I don’t see a benefit over EF Core."),Zr.forEach(i),aa=c(P),Ve=s(P,"LI",{});var en=r(Ve);we=s(en,"A",{href:!0,rel:!0});var Ln=r(we);sa=o(Ln,"Roundhouse"),Ln.forEach(i),la=o(en," but again this is .NET-specific, it also seems to be poorly maintained although I do like the convention-over-configuration approach at a glance"),en.forEach(i),P.forEach(i),Eo=c(l),G=s(l,"P",{});var at=r(G);ra=o(at,"I eventually settled on "),Ee=s(at,"A",{href:!0,rel:!0});var Cn=r(Ee);na=o(Cn,"Liquibase"),Cn.forEach(i),ca=o(at," because it has a free and open source option (Apache-2.0 licensed), supports Docker, is clearly built to support CI/CD with documented "),_e=s(at,"A",{href:!0,rel:!0});var Tn=r(_e);ua=o(Tn,"Open Source Workflows"),Tn.forEach(i),da=o(at," and, crucially, it works with the visualisation tool I’ve selected."),at.forEach(i),_o=c(l),Ue=s(l,"H2",{});var xn=r(Ue);ha=o(xn,"Testability"),xn.forEach(i),qo=c(l),R=s(l,"P",{});var ae=r(R);fa=o(ae,"The prompt for this mini-project was the discovery of "),qe=s(ae,"A",{href:!0,rel:!0});var Rn=r(qe);pa=o(Rn,"Testcontainers"),Rn.forEach(i),ma=o(ae," (via Nick Chapsas on Youtube)."),ba=s(ae,"BR",{}),ga=o(ae,`
This allows you to spin up a throwaway docker container, or collection of, just for the lifetime of the test(s).`),va=s(ae,"BR",{}),ya=o(ae,`
This is not a substitute for unit testing since it will be significantly slower, but it is a better solution than testing with in-memory databases, which may have subtle differences in behaviour to the production database.`),ae.forEach(i),Io=c(l),Ke=s(l,"H2",{});var Bn=r(Ke);wa=o(Bn,"The solution"),Bn.forEach(i),So=c(l),Ye=s(l,"H3",{});var An=r(Ye);Ea=o(An,"Initial setup"),An.forEach(i),Do=c(l),f=s(l,"OL",{});var b=r(f);gt=s(b,"LI",{});var Fn=r(gt);_a=o(Fn,"Install Docker (and optionally Docker Desktop, if licencing allows), examples below are unix images on Windows."),Fn.forEach(i),qa=c(b),oe=s(b,"LI",{});var co=r(oe);Ia=o(co,"Run SQL instance (example is MSSQL) for any manual testing and to prove scripts"),Sa=s(co,"BR",{}),Da=c(co),vt=s(co,"CODE",{});var On=r(vt);ka=o(On,'docker run --name "mssql_manual_test" -e "ACCEPT_EULA=Y" -e "MSSQL_SA_PASSWORD=yourStrong(!)Password" -p 1433:1433 -d mcr.microsoft.com/mssql/server:2022-latest'),On.forEach(i),co.forEach(i),La=c(b),Je=s(b,"LI",{});var tn=r(Je);Ca=o(tn,"Get latest liquibase image "),yt=s(tn,"CODE",{});var Pn=r(yt);Ta=o(Pn,"docker pull liquibase/liquibase"),Pn.forEach(i),tn.forEach(i),xa=c(b),wt=s(b,"LI",{});var Mn=r(wt);Ra=o(Mn,"Install VS Code extension “ERD Editor” (vuerd)"),Mn.forEach(i),Ba=c(b),Ie=s(b,"LI",{});var Ao=r(Ie);Aa=o(Ao,"Create an ERD file "),Et=s(Ao,"CODE",{});var Qn=r(Et);Fa=o(Qn,"<name>.vuerd.json"),Qn.forEach(i),Oa=o(Ao," within the project/solution/workspace, open this in VS Code and it should automatically load the editor."),Ao.forEach(i),Pa=c(b),g=s(b,"LI",{});var w=r(g);Ma=o(w,"Create a DB model, be sure not to deselect Postgres as the output regardless of target DB type, required for Liquibase support"),Qa=s(w,"BR",{}),Wa=o(w,`
Be careful here to use appropriate data types for the target environment, `),Se=s(w,"A",{href:!0,rel:!0});var Wn=r(Se);Na=o(Wn,"ERD Editor supported types"),Wn.forEach(i),ja=o(w,"."),Ha=s(w,"BR",{}),Ga=o(w,`
The tool is clever enough to convert from `),_t=s(w,"CODE",{});var Nn=r(_t);Va=o(Nn,"uuid"),Nn.forEach(i),Ua=o(w," to "),qt=s(w,"CODE",{});var jn=r(qt);Ka=o(jn,"uniqueidentifier"),jn.forEach(i),Ya=o(w,", but not clever enough to convert from "),It=s(w,"CODE",{});var Hn=r(It);Ja=o(Hn,"varchar"),Hn.forEach(i),za=o(w," to "),St=s(w,"CODE",{});var Gn=r(St);$a=o(Gn,"varchar2"),Gn.forEach(i),Xa=o(w," for example and certainly not when lengths are included (which they need to be since the default is 1 character)."),Za=s(w,"BR",{}),es=o(w,`
Effectively I’d advise making multiple DB models if supporting multiple DB providers, but decide which is master, copy/paste, find/replace in JSON files to keep multiple versions in sync and versioned together (this is why models should be stored in text format).`),w.forEach(i),ts=c(b),y=s(b,"LI",{});var D=r(y);os=o(D,"Generate a Liquibase changeset by right clicking the model and selecting Export > Liquibase"),is=s(D,"BR",{}),as=o(D,`
Use the naming convention `),Dt=s(D,"EM",{});var Vn=r(Dt);ss=o(Vn,"liquibase-change-###"),Vn.forEach(i),ls=o(D,", 999 DB changes should be enough for most projects."),rs=s(D,"BR",{}),ns=o(D,`
Liquibase uses the id, author and filename to track changes - `),De=s(D,"A",{href:!0,rel:!0});var Un=r(De);cs=o(Un,"How Liquibase works"),Un.forEach(i),us=s(D,"BR",{}),ds=o(D,`
Keep the changelogs alongside the ERD model in source code, this lets ERD Editor load older changelogs to guarantee correct generation of new changelogs.`),hs=s(D,"BR",{}),fs=o(D,`
To apply multiple chainsets automatically, which we will need for automation, it is necessary to manually configure a master changelog `),kt=s(D,"CODE",{});var Kn=r(kt);ps=o(Kn,"liquibase-change.xml"),Kn.forEach(i),ms=o(D,"."),D.forEach(i),bs=c(b),_=s(b,"LI",{});var L=r(_);gs=o(L,"Configure liquibase using a "),Lt=s(L,"EM",{});var Yn=r(Lt);vs=o(Yn,"liquibase.properties"),Yn.forEach(i),ys=o(L," file in the same folder:  "),ze=s(L,"PRE",{class:!0});var Pc=r(ze);Pc.forEach(i),ws=o(L,"This example is using the defaults for a "),ke=s(L,"A",{href:!0,rel:!0});var Jn=r(ke);Es=o(Jn,"SQL Server docker"),Jn.forEach(i),_s=o(L," container, although the "),Le=s(L,"A",{href:!0,rel:!0});var zn=r(Le);qs=o(zn,"Liquibase recommendation"),zn.forEach(i),Is=o(L," is to pass these as arguments.  Passing by argument is also required for running multiple test sets in parallel since only one Docker container at a time can respond on a given port, even if we reuse credentials for testing, so this defaultsFile is kept just to simplify any manual test processes locally."),Ss=s(L,"BR",{}),Ds=o(L,`
We require `),Ct=s(L,"CODE",{});var $n=r(Ct);ks=o($n,"encrypt=true and trustServerCertificate=true"),$n.forEach(i),Ls=o(L," to resolve firewall and SSL errors respectively, encountered whilst applying test changeset."),L.forEach(i),Cs=c(b),p=s(b,"LI",{});var m=r(p);Ts=o(m,"We can now run liquibase commands, e.g. help"),xs=s(m,"BR",{}),Rs=c(m),Tt=s(m,"CODE",{});var Xn=r(Tt);Bs=o(Xn,'docker run --rm --net=host -v "C:\\Path\\To\\Folder\\Containing\\changelogs":/liquibase/changelog liquibase/liquibase --defaultsFile=/liquibase/changelog/liquibase.properties --help'),Xn.forEach(i),As=s(m,"BR",{}),Fs=c(m),xt=s(m,"CODE",{});var Zn=r(xt);Os=o(Zn,"--rm"),Zn.forEach(i),Ps=o(m," ensures that the docker container is removed after completion of the script (see debugging)"),Ms=s(m,"BR",{}),Qs=c(m),Rt=s(m,"CODE",{});var ec=r(Rt);Ws=o(ec,"-net=host"),ec.forEach(i),Ns=o(m," ensures that the liquibase container can talk outside of the Docker bridge network (e.g. to connect to a Docker hosted DB).  In hindsight it is better to use internal network alias on the SQL container to connect from liquibase."),js=s(m,"BR",{}),Hs=c(m),Bt=s(m,"CODE",{});var tc=r(Bt);Gs=o(tc,"-v"),tc.forEach(i),Vs=o(m," maps our local folder (Windows in this example) to the root of Liquibase’s changelog tree volume."),Us=s(m,"BR",{}),Ks=c(m),At=s(m,"CODE",{});var oc=r(At);Ys=o(oc,"--defaultsFile"),oc.forEach(i),Js=o(m," tells Liquibase to use our properties file, which in turn tells it where to find changelogs and how to connect to the DB."),zs=s(m,"BR",{}),$s=c(m),Ft=s(m,"CODE",{});var ic=r(Ft);Xs=o(ic,"--help"),ic.forEach(i),Zs=o(m," tells Liquibase to show us its help documentation, including available commands"),m.forEach(i),el=c(b),v=s(b,"LI",{});var E=r(v);tl=o(E,"Debugging - if any of our commands fail we can investigate by launching Liquibase with a built-in in-memory DB:"),ol=s(E,"BR",{}),il=c(E),Ot=s(E,"CODE",{});var ac=r(Ot);al=o(ac,'docker run --net=host -v "C:\\Path\\To\\Folder\\Containing\\changelogs":/liquibase/changelog liquibase/liquibase --defaultsFile=/liquibase/changelog/liquibase.properties init start-h2'),ac.forEach(i),sl=s(E,"BR",{}),ll=o(E,`
In a separate command window find the running container using `),Pt=s(E,"CODE",{});var sc=r(Pt);rl=o(sc,"docker ps"),sc.forEach(i),nl=s(E,"BR",{}),cl=o(E,`
Jump inside it using `),Mt=s(E,"CODE",{});var lc=r(Mt);ul=o(lc,"docker exec -it <container_id> bash"),lc.forEach(i),dl=o(E,", you should see your files within "),Qt=s(E,"CODE",{});var rc=r(Qt);hl=o(rc,"/changelog"),rc.forEach(i),fl=s(E,"BR",{}),pl=o(E,`
From here you can run the same commands (everything after liquibase/liquibase) on top of liquibase directly, e.g. `),Wt=s(E,"CODE",{});var nc=r(Wt);ml=o(nc,"liquibase --help"),nc.forEach(i),bl=s(E,"BR",{}),gl=o(E,`
When done you will need to stop and remove the docker container yourself.`),E.forEach(i),vl=c(b),V=s(b,"LI",{});var Fe=r(V);yl=o(Fe,"Apply the changeset to the database manually (dbo schema is default for SQL Server)"),wl=s(Fe,"BR",{}),El=c(Fe),Nt=s(Fe,"CODE",{});var cc=r(Nt);_l=o(cc,'docker run --rm --net=host -v "C:\\Path\\To\\Folder\\Containing\\changelogs":/liquibase/changelog liquibase/liquibase --defaultsFile=/liquibase/changelog/liquibase.properties update --changelog-file=liquibase-change-001.xml --default-schema-name=dbo'),cc.forEach(i),ql=s(Fe,"BR",{}),Il=o(Fe,`
If a changeset fails in dev, perhaps due to messing up constraints :|, and you wish to keep changesets clean before commit, you can truncate the table DATABASECHANGELOG which Liquibase manages.`),Fe.forEach(i),Sl=c(b),jt=s(b,"LI",{});var uc=r(jt);Dl=o(uc,"Check that this has worked as expected using SQL Server Object Explorer in Visual Studio or SQL browser of preference."),uc.forEach(i),b.forEach(i),ko=c(l),$e=s(l,"H3",{});var dc=r($e);kl=o(dc,"Code changes"),dc.forEach(i),Lo=c(l),B=s(l,"OL",{});var se=r(B);Ce=s(se,"LI",{});var Fo=r(Ce);Y=s(Fo,"P",{});var st=r(Y);Ll=o(st,"Ensure that any DB code (repository) accesses the connection string via "),Ht=s(st,"CODE",{});var hc=r(Ht);Cl=o(hc,"IOptions"),hc.forEach(i),Tl=o(st," or better yet "),Gt=s(st,"CODE",{});var fc=r(Gt);xl=o(fc,"IOptionsSnapshot"),fc.forEach(i),Rl=o(st," to allow live reloading of config."),st.forEach(i),Bl=c(Fo),Xe=s(Fo,"PRE",{class:!0});var Mc=r(Xe);Mc.forEach(i),Fo.forEach(i),Al=c(se),Te=s(se,"LI",{});var Oo=r(Te);Q=s(Oo,"P",{});var le=r(Q);Fl=o(le,"Create an xUnit IClassFixture "),Vt=s(le,"CODE",{});var pc=r(Vt);Ol=o(pc,"MsSqlTestFixture"),pc.forEach(i),Pl=o(le,", implementing "),Ut=s(le,"CODE",{});var mc=r(Ut);Ml=o(mc,"IAsyncLifetime"),mc.forEach(i),Ql=o(le," to ensure that it runs once per test class which uses it."),Wl=s(le,"BR",{}),Nl=o(le,`
This class will:`),le.forEach(i),jl=c(Oo),C=s(Oo,"OL",{});var K=r(C);xe=s(K,"LI",{});var Po=r(xe);Hl=o(Po,"Create a SQL container using the "),Kt=s(Po,"CODE",{});var bc=r(Kt);Gl=o(bc,"ContainerBuilder"),bc.forEach(i),Vl=o(Po,", mirroring the parameters above, although with a dynamically generated port."),Po.forEach(i),Ul=c(K),Yt=s(K,"LI",{});var gc=r(Yt);Kl=o(gc,"Wait for this to become responsive (by which I mean can accept SQL commands not just commands at the Docker/network layer)"),gc.forEach(i),Yl=c(K),Re=s(K,"LI",{});var Mo=r(Re);Jl=o(Mo,"Spin up a Liquibase container to run a single command on this transient database - "),Jt=s(Mo,"CODE",{});var vc=r(Jt);zl=o(vc,"update"),vc.forEach(i),$l=o(Mo,", to apply all changes to get to the current version from an empty database and dispose it after completion."),Mo.forEach(i),Xl=c(K),zt=s(K,"LI",{});var yc=r(zt);Zl=o(yc,"Expose SQL connection details via internal constants, for use by the test application."),yc.forEach(i),er=c(K),$t=s(K,"LI",{});var wc=r($t);tr=o(wc,"Dispose the SQL container and associated classes after test execution."),wc.forEach(i),K.forEach(i),Oo.forEach(i),or=c(se),J=s(se,"LI",{});var lt=r(J);W=s(lt,"P",{});var re=r(W);ir=o(re,"Create a custom "),Xt=s(re,"CODE",{});var Ec=r(Xt);ar=o(Ec,"WebApplicationFactory"),Ec.forEach(i),sr=o(re," for testing, e.g. "),Zt=s(re,"CODE",{});var _c=r(Zt);lr=o(_c,"TestWebApplicationFactory"),_c.forEach(i),rr=o(re,"."),nr=s(re,"BR",{}),cr=o(re,`
This class will:`),re.forEach(i),ur=c(lt),N=s(lt,"OL",{});var ne=r(N);eo=s(ne,"LI",{});var qc=r(eo);dr=o(qc,"Start with the WebApplicationFactory used by the application itself."),qc.forEach(i),hr=c(ne),to=s(ne,"LI",{});var Ic=r(to);fr=o(Ic,"Replace real external dependencies in favour of managed stubs/fakes (out of scope of this document)."),Ic.forEach(i),pr=c(ne),oo=s(ne,"LI",{});var Sc=r(oo);mr=o(Sc,"Use constructor injection to load the SQL TestFixture which exposes the connection details of the transient database."),Sc.forEach(i),br=c(ne),io=s(ne,"LI",{});var Dc=r(io);gr=o(Dc,"Replace real connection strings with a connection string built from the SQL container settings."),Dc.forEach(i),ne.forEach(i),vr=c(lt),Ze=s(lt,"PRE",{class:!0});var Qc=r(Ze);Qc.forEach(i),lt.forEach(i),yr=c(se),Be=s(se,"LI",{});var Qo=r(Be);A=s(Qo,"P",{});var $=r(A);wr=o($,"Create a test class "),ao=s($,"CODE",{});var kc=r(ao);Er=o(kc,"MsSqlTests"),kc.forEach(i),_r=o($," which inherits "),so=s($,"CODE",{});var Lc=r(so);qr=o(Lc,"IClassFixture<MsSqlTestFixture>"),Lc.forEach(i),Ir=o($," and "),lo=s($,"CODE",{});var Cc=r(lo);Sr=o(Cc,"IDisposable"),Cc.forEach(i),Dr=s($,"BR",{}),kr=o($,`
In the constructor use the above classes to make the DB available to the tests:`),$.forEach(i),Lr=c(Qo),et=s(Qo,"PRE",{class:!0});var Wc=r(et);Wc.forEach(i),Qo.forEach(i),se.forEach(i),Co=c(l),tt=s(l,"H3",{});var Tc=r(tt);Cr=o(Tc,"Issues"),Tc.forEach(i),To=c(l),S=s(l,"P",{});var M=r(S);Tr=o(M,"It takes some time to spin up a liquibase container, connect to a SQL database and apply migration scripts."),xr=s(M,"BR",{}),Rr=o(M,`
I found during exploration that whilst debugging the test everything was working as designed, however, whilst running the tests had completed (with failures) before the DB scripts had been executed.`),Br=s(M,"BR",{}),Ar=o(M,`
It is possible to set a WaitStrategy on testcontainers to ensure that they are ready before moving on.`),Fr=s(M,"BR",{}),Or=o(M,`
I had no luck getting this to work with liquibase, since it is not designed to stay up after the command is completed.`),Pr=s(M,"BR",{}),Mr=o(M,`
I’m sure there’s a better way, but my fix for this was to put a while loop in between starting and disposing the liquibase container.`),Qr=s(M,"BR",{}),Wr=o(M,`
This simply runs an appropriate query on the SQL container which indicates completion, then waits for a second before retrying, up to N times.`),M.forEach(i),xo=c(l),ot=s(l,"H3",{});var xc=r(ot);Nr=o(xc,"Next steps"),xc.forEach(i),Ro=c(l),F=s(l,"P",{});var ce=r(F);jr=o(ce,"The solution now works as intended (as long as you remember to start Docker first)."),Hr=s(ce,"BR",{}),Gr=o(ce,`
I simply need to complete the work now, in a more test driven fashion than I normally would.`),Vr=s(ce,"BR",{}),Ur=o(ce,`
Finally I need to automate integration testing on CICD pipelines.`),Kr=s(ce,"BR",{}),Yr=o(ce,`
All of the above is checked in to a private GitHub repo for now, I may make this public at some point.`),ce.forEach(i),this.h()},h(){h(ue,"href","https://learnsql.com/blog/history-of-sql-standards/"),h(ue,"rel","nofollow"),h(de,"href","https://github.com/microsoft/DacFx"),h(de,"rel","nofollow"),h(he,"href","https://mermaid.js.org/syntax/entityRelationshipDiagram.html"),h(he,"rel","nofollow"),h(fe,"href","https://dbdiagram.io/home/"),h(fe,"rel","nofollow"),h(pe,"href","https://structurizr.com/dsl?example=getting-started"),h(pe,"rel","nofollow"),h(me,"href","https://marketplace.visualstudio.com/items?itemName=dineug.vuerd-vscode"),h(me,"rel","nofollow"),h(be,"href","https://learn.microsoft.com/en-us/sql/ssdt/extract-publish-and-register-dacpac-files?view=sql-server-ver16"),h(be,"rel","nofollow"),h(ge,"href","https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/?tabs=dotnet-core-cli"),h(ge,"rel","nofollow"),h(ve,"href","https://www.red-gate.com/solutions/need/automate"),h(ve,"rel","nofollow"),h(ye,"href","https://fluentmigrator.github.io"),h(ye,"rel","nofollow"),h(we,"href","https://github.com/chucknorris/roundhouse/wiki"),h(we,"rel","nofollow"),h(Ee,"href","https://www.liquibase.com/download"),h(Ee,"rel","nofollow"),h(_e,"href","https://docs.liquibase.com/workflows/liquibase-community/home.html"),h(_e,"rel","nofollow"),h(qe,"href","https://github.com/testcontainers"),h(qe,"rel","nofollow"),h(Se,"href","https://github.com/dineug/erd-editor/blob/master/packages/sql-ddl-parser/src/SQL_DDL_Test_Case.md"),h(Se,"rel","nofollow"),h(De,"href","https://www.liquibase.com/how-liquibase-works"),h(De,"rel","nofollow"),h(ze,"class","language-undefined"),h(ke,"href","https://hub.docker.com/_/microsoft-mssql-server"),h(ke,"rel","nofollow"),h(Le,"href","https://docs.liquibase.com/workflows/liquibase-community/using-liquibase-and-docker.html"),h(Le,"rel","nofollow"),h(Xe,"class","language-c#"),h(Ze,"class","language-c#"),h(et,"class","language-c#")},m(l,u){d(l,X,u),e(X,Wo),d(l,uo,u),d(l,j,u),e(j,No),e(j,jo),e(j,Ho),e(j,Go),e(j,Vo),d(l,ho,u),d(l,Oe,u),e(Oe,Uo),d(l,fo,u),d(l,k,u),e(k,Z),e(Z,rt),e(rt,Ko),e(Z,Yo),e(Z,Jo),e(Z,zo),e(k,$o),e(k,H),e(H,nt),e(nt,Xo),e(H,Zo),e(H,ei),e(H,ti),e(H,oi),e(H,ii),e(k,ai),e(k,ee),e(ee,ct),e(ct,si),e(ee,li),e(ee,ri),e(ee,ni),e(k,ci),e(k,T),e(T,ut),e(ut,ui),e(T,di),e(T,hi),e(T,fi),e(T,ue),e(ue,pi),e(T,mi),e(T,de),e(de,bi),e(T,gi),e(k,vi),e(k,Pe),e(Pe,dt),e(dt,yi),e(Pe,wi),d(l,po,u),d(l,Me,u),e(Me,Ei),d(l,mo,u),d(l,Qe,u),e(Qe,_i),d(l,bo,u),d(l,q,u),e(q,qi),e(q,he),e(he,Ii),e(q,Si),e(q,fe),e(fe,Di),e(q,ki),e(q,pe),e(pe,Li),e(q,Ci),e(q,me),e(me,Ti),e(q,xi),e(q,Ri),e(q,Bi),d(l,go,u),d(l,x,u),e(x,ht),e(ht,Ai),e(x,Fi),e(x,ft),e(ft,Oi),e(x,Pi),e(x,pt),e(pt,Mi),e(x,Qi),e(x,mt),e(mt,Wi),d(l,vo,u),d(l,We,u),e(We,Ni),d(l,yo,u),d(l,te,u),e(te,ji),e(te,Hi),e(te,Gi),d(l,wo,u),d(l,I,u),e(I,bt),e(bt,Vi),e(I,Ui),e(I,Ne),e(Ne,be),e(be,Ki),e(Ne,Yi),e(I,Ji),e(I,je),e(je,ge),e(ge,zi),e(je,$i),e(I,Xi),e(I,He),e(He,ve),e(ve,Zi),e(He,ea),e(I,ta),e(I,Ge),e(Ge,ye),e(ye,oa),e(Ge,ia),e(I,aa),e(I,Ve),e(Ve,we),e(we,sa),e(Ve,la),d(l,Eo,u),d(l,G,u),e(G,ra),e(G,Ee),e(Ee,na),e(G,ca),e(G,_e),e(_e,ua),e(G,da),d(l,_o,u),d(l,Ue,u),e(Ue,ha),d(l,qo,u),d(l,R,u),e(R,fa),e(R,qe),e(qe,pa),e(R,ma),e(R,ba),e(R,ga),e(R,va),e(R,ya),d(l,Io,u),d(l,Ke,u),e(Ke,wa),d(l,So,u),d(l,Ye,u),e(Ye,Ea),d(l,Do,u),d(l,f,u),e(f,gt),e(gt,_a),e(f,qa),e(f,oe),e(oe,Ia),e(oe,Sa),e(oe,Da),e(oe,vt),e(vt,ka),e(f,La),e(f,Je),e(Je,Ca),e(Je,yt),e(yt,Ta),e(f,xa),e(f,wt),e(wt,Ra),e(f,Ba),e(f,Ie),e(Ie,Aa),e(Ie,Et),e(Et,Fa),e(Ie,Oa),e(f,Pa),e(f,g),e(g,Ma),e(g,Qa),e(g,Wa),e(g,Se),e(Se,Na),e(g,ja),e(g,Ha),e(g,Ga),e(g,_t),e(_t,Va),e(g,Ua),e(g,qt),e(qt,Ka),e(g,Ya),e(g,It),e(It,Ja),e(g,za),e(g,St),e(St,$a),e(g,Xa),e(g,Za),e(g,es),e(f,ts),e(f,y),e(y,os),e(y,is),e(y,as),e(y,Dt),e(Dt,ss),e(y,ls),e(y,rs),e(y,ns),e(y,De),e(De,cs),e(y,us),e(y,ds),e(y,hs),e(y,fs),e(y,kt),e(kt,ps),e(y,ms),e(f,bs),e(f,_),e(_,gs),e(_,Lt),e(Lt,vs),e(_,ys),e(_,ze),ze.innerHTML=Bc,e(_,ws),e(_,ke),e(ke,Es),e(_,_s),e(_,Le),e(Le,qs),e(_,Is),e(_,Ss),e(_,Ds),e(_,Ct),e(Ct,ks),e(_,Ls),e(f,Cs),e(f,p),e(p,Ts),e(p,xs),e(p,Rs),e(p,Tt),e(Tt,Bs),e(p,As),e(p,Fs),e(p,xt),e(xt,Os),e(p,Ps),e(p,Ms),e(p,Qs),e(p,Rt),e(Rt,Ws),e(p,Ns),e(p,js),e(p,Hs),e(p,Bt),e(Bt,Gs),e(p,Vs),e(p,Us),e(p,Ks),e(p,At),e(At,Ys),e(p,Js),e(p,zs),e(p,$s),e(p,Ft),e(Ft,Xs),e(p,Zs),e(f,el),e(f,v),e(v,tl),e(v,ol),e(v,il),e(v,Ot),e(Ot,al),e(v,sl),e(v,ll),e(v,Pt),e(Pt,rl),e(v,nl),e(v,cl),e(v,Mt),e(Mt,ul),e(v,dl),e(v,Qt),e(Qt,hl),e(v,fl),e(v,pl),e(v,Wt),e(Wt,ml),e(v,bl),e(v,gl),e(f,vl),e(f,V),e(V,yl),e(V,wl),e(V,El),e(V,Nt),e(Nt,_l),e(V,ql),e(V,Il),e(f,Sl),e(f,jt),e(jt,Dl),d(l,ko,u),d(l,$e,u),e($e,kl),d(l,Lo,u),d(l,B,u),e(B,Ce),e(Ce,Y),e(Y,Ll),e(Y,Ht),e(Ht,Cl),e(Y,Tl),e(Y,Gt),e(Gt,xl),e(Y,Rl),e(Ce,Bl),e(Ce,Xe),Xe.innerHTML=Ac,e(B,Al),e(B,Te),e(Te,Q),e(Q,Fl),e(Q,Vt),e(Vt,Ol),e(Q,Pl),e(Q,Ut),e(Ut,Ml),e(Q,Ql),e(Q,Wl),e(Q,Nl),e(Te,jl),e(Te,C),e(C,xe),e(xe,Hl),e(xe,Kt),e(Kt,Gl),e(xe,Vl),e(C,Ul),e(C,Yt),e(Yt,Kl),e(C,Yl),e(C,Re),e(Re,Jl),e(Re,Jt),e(Jt,zl),e(Re,$l),e(C,Xl),e(C,zt),e(zt,Zl),e(C,er),e(C,$t),e($t,tr),e(B,or),e(B,J),e(J,W),e(W,ir),e(W,Xt),e(Xt,ar),e(W,sr),e(W,Zt),e(Zt,lr),e(W,rr),e(W,nr),e(W,cr),e(J,ur),e(J,N),e(N,eo),e(eo,dr),e(N,hr),e(N,to),e(to,fr),e(N,pr),e(N,oo),e(oo,mr),e(N,br),e(N,io),e(io,gr),e(J,vr),e(J,Ze),Ze.innerHTML=Fc,e(B,yr),e(B,Be),e(Be,A),e(A,wr),e(A,ao),e(ao,Er),e(A,_r),e(A,so),e(so,qr),e(A,Ir),e(A,lo),e(lo,Sr),e(A,Dr),e(A,kr),e(Be,Lr),e(Be,et),et.innerHTML=Oc,d(l,Co,u),d(l,tt,u),e(tt,Cr),d(l,To,u),d(l,S,u),e(S,Tr),e(S,xr),e(S,Rr),e(S,Br),e(S,Ar),e(S,Fr),e(S,Or),e(S,Pr),e(S,Mr),e(S,Qr),e(S,Wr),d(l,xo,u),d(l,ot,u),e(ot,Nr),d(l,Ro,u),d(l,F,u),e(F,jr),e(F,Hr),e(F,Gr),e(F,Vr),e(F,Ur),e(F,Kr),e(F,Yr)},p:on,i:on,o:on,d(l){l&&i(X),l&&i(uo),l&&i(j),l&&i(ho),l&&i(Oe),l&&i(fo),l&&i(k),l&&i(po),l&&i(Me),l&&i(mo),l&&i(Qe),l&&i(bo),l&&i(q),l&&i(go),l&&i(x),l&&i(vo),l&&i(We),l&&i(yo),l&&i(te),l&&i(wo),l&&i(I),l&&i(Eo),l&&i(G),l&&i(_o),l&&i(Ue),l&&i(qo),l&&i(R),l&&i(Io),l&&i(Ke),l&&i(So),l&&i(Ye),l&&i(Do),l&&i(f),l&&i(ko),l&&i($e),l&&i(Lo),l&&i(B),l&&i(Co),l&&i(tt),l&&i(To),l&&i(S),l&&i(xo),l&&i(ot),l&&i(Ro),l&&i(F)}}}class Uc extends Nc{constructor(X){super(),jc(this,X,null,Gc,Hc,{})}}export{Uc as default};
