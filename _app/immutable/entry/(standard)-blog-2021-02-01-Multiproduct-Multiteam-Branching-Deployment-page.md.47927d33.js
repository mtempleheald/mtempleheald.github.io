import{S as li,i as ri,s as ai,k as o,q as r,a as s,l as i,m as n,r as a,h as t,c as d,b as f,I as e,C as _o}from"../chunks/index.de0bb5b5.js";function si(ni){let E,Ae,xe,j,Fe,Se,T,Ne,je,D,Be,Te,h,K,Re,Pe,U,Ve,y,X,Qe,Ge,Y,Je,Ke,Z,Xe,Ye,$,Ze,$e,ee,et,tt,te,ot,it,oe,nt,De,C,lt,Ue,u,M,rt,ie,ne,at,st,H,dt,I,le,ct,ft,re,ht,ut,O,pt,L,ae,mt,vt,se,bt,gt,W,wt,de,ce,yt,Et,q,_t,fe,he,It,Ce,z,Lt,Me,p,A,kt,k,ue,xt,St,pe,jt,Tt,F,Dt,x,N,me,Ut,Ct,Mt,ve,Ht,Ot,B,Wt,S,be,qt,zt,ge,At,Ft,we,Nt,Bt,R,Rt,m,_,ye,Pt,Vt,Qt,Gt,Jt,P,Ee,Kt,Xt,Yt,V,_e,Zt,$t,eo,Q,Ie,to,oo,io,G,Le,no,lo;return{c(){E=o("h1"),Ae=r("Multiproduct, Multiteam Branching Strategy & Deployment"),xe=s(),j=o("h2"),Fe=r("Background"),Se=s(),T=o("p"),Ne=r(`I was working at a company whose current software estate included multiple independent CMS websites hosted in separate Sitefinity instances (.NET Framework, IIS).
These websites had been left to rot, were running old versions of the software and the software team were unable to respond effectively to changing business requirements.
The decision was made to consolidate the different sites into a single multisite instance to maximise code sharing and faciliate easier upgrades and security patches.
This migration was planned over a very short timescale and therefore third party service providers were needed to make up the developer resource shortfall.`),je=s(),D=o("h2"),Be=r("The situation"),Te=s(),h=o("ul"),K=o("li"),Re=r("1 .NET Framework MVC solution with global configuration and shared components"),Pe=s(),U=o("li"),Ve=r("IIS Hosting on Windows VMs, limited to 3 environments (no infrastructure automation, sadly):"),y=o("ul"),X=o("li"),Qe=r("QA to test components"),Ge=s(),Y=o("li"),Je=r("staging to build and test website"),Ke=s(),Z=o("li"),Xe=r("highly available production environment"),Ye=s(),$=o("li"),Ze=r("Half a dozen concurrent projects, spread across staff in 3 companies"),$e=s(),ee=o("li"),et=r("Waterfall project delivery and business-led manual testing timescales (yes, I know!)"),tt=s(),te=o("li"),ot=r("Azure DevOps hosted git repositories"),it=s(),oe=o("li"),nt=r("Undecided repository structure/ branching strategy/ deployment mechanism and little time to implement"),De=s(),C=o("h2"),lt=r("Requirement consideration"),Ue=s(),u=o("ul"),M=o("li"),rt=r("common upgrade mechanism for all products (1 product == 1 website == 1 project == 1 team)"),ie=o("ul"),ne=o("li"),at=r("choose monorepo - this way only one version of the solution needs upgrading"),st=s(),H=o("li"),dt=r("Independent development of different products"),I=o("ul"),le=o("li"),ct=r("use git branches to keep products separate without the need for synchronous communication between teams"),ft=s(),re=o("li"),ht=r("standardise where possible for a consistent history and to aid centralised governance"),ut=s(),O=o("li"),pt=r("Independent deployment of different products to the same environment"),L=o("ul"),ae=o("li"),mt=r("partial deployments from independent pipelines/branches proved too difficult to manage"),vt=s(),se=o("li"),bt=r("merging both products to a common branch and deploying using a master pipeline is more reliable (if merge conflicts can be handled)"),gt=s(),W=o("li"),wt=r("Decoupled products which can be deployed in different orders to different environments"),de=o("ul"),ce=o("li"),yt=r("we need to merge products together for deployment but must not couple, so don’t pull code down from this “environment” branch"),Et=s(),q=o("li"),_t=r("With all of these independently developed branch merging together we need to avoid merge conflicts"),fe=o("ul"),he=o("li"),It=r("identify the shared elements and see how best to manage each"),Ce=s(),z=o("h2"),Lt=r("The solution"),Me=s(),p=o("ul"),A=o("li"),kt=r("Deployment through Azure DevOps pipelines"),k=o("ul"),ue=o("li"),xt=r("yaml release pipelines provide better audit trail"),St=s(),pe=o("li"),jt=r("entire solution built and deployed together, ensuring that all products build when combined"),Tt=s(),F=o("li"),Dt=r("Environment branches used to join different products together for deployment"),x=o("ul"),N=o("li"),me=o("em"),Ut=r("never"),Ct=r(" merge these back down into product branches to avoid coupling."),Mt=s(),ve=o("li"),Ht=r("only release branches ever merged (PR) to environment branches. This ensures that any environment contains a known version of each product."),Ot=s(),B=o("li"),Wt=r("Maintain a separate develop branch for each product, for the lifetime of a project"),S=o("ul"),be=o("li"),qt=r("these branches based off a root master/main and should be pulled down regularly as usual."),zt=s(),ge=o("li"),At=r("development can loosely follow a git-flow process from here, features and fixes to the relevant develop branch, hotfixes to master"),Ft=s(),we=o("li"),Nt=r("Short-lived pieces of work can be based off master as hotfixes"),Bt=s(),R=o("li"),Rt=r("Do not change shared files within projects if possible, communicate the changes across teams if not"),m=o("ul"),_=o("li"),ye=o("code"),Pt=r("*.csproj"),Vt=r(" project files - .NET Framework lists specific files, which causes many merge conflicts."),Qt=o("br"),Gt=r(`
Use wildcards to avoid ever having to change this file, this is possible because Sitefinity is a consistent framework, use hotfix for adding new patterns.`),Jt=s(),P=o("li"),Ee=o("code"),Kt=r("*.yml"),Xt=r(" pipelines - treat these as hotfixes, add check for presence of project before attempting to build"),Yt=s(),V=o("li"),_e=o("code"),Zt=r("Web.config"),$t=r(" + transformations - don’t make breaking changes, add redirect rules, new config values etc as hotfixes"),eo=s(),Q=o("li"),Ie=o("code"),to=r("*Config.config"),oo=r(" + transformations - Sitefinity configuration - don’t make breaking changes, treat changes as hotfixes"),io=s(),G=o("li"),Le=o("code"),no=r("Sitefinity.lic"),lo=r(" licence file - treat as hotfix")},l(l){E=i(l,"H1",{});var c=n(E);Ae=a(c,"Multiproduct, Multiteam Branching Strategy & Deployment"),c.forEach(t),xe=d(l),j=i(l,"H2",{});var Io=n(j);Fe=a(Io,"Background"),Io.forEach(t),Se=d(l),T=i(l,"P",{});var Lo=n(T);Ne=a(Lo,`I was working at a company whose current software estate included multiple independent CMS websites hosted in separate Sitefinity instances (.NET Framework, IIS).
These websites had been left to rot, were running old versions of the software and the software team were unable to respond effectively to changing business requirements.
The decision was made to consolidate the different sites into a single multisite instance to maximise code sharing and faciliate easier upgrades and security patches.
This migration was planned over a very short timescale and therefore third party service providers were needed to make up the developer resource shortfall.`),Lo.forEach(t),je=d(l),D=i(l,"H2",{});var ko=n(D);Be=a(ko,"The situation"),ko.forEach(t),Te=d(l),h=i(l,"UL",{});var v=n(h);K=i(v,"LI",{});var xo=n(K);Re=a(xo,"1 .NET Framework MVC solution with global configuration and shared components"),xo.forEach(t),Pe=d(v),U=i(v,"LI",{});var ro=n(U);Ve=a(ro,"IIS Hosting on Windows VMs, limited to 3 environments (no infrastructure automation, sadly):"),y=i(ro,"UL",{});var J=n(y);X=i(J,"LI",{});var So=n(X);Qe=a(So,"QA to test components"),So.forEach(t),Ge=d(J),Y=i(J,"LI",{});var jo=n(Y);Je=a(jo,"staging to build and test website"),jo.forEach(t),Ke=d(J),Z=i(J,"LI",{});var To=n(Z);Xe=a(To,"highly available production environment"),To.forEach(t),J.forEach(t),ro.forEach(t),Ye=d(v),$=i(v,"LI",{});var Do=n($);Ze=a(Do,"Half a dozen concurrent projects, spread across staff in 3 companies"),Do.forEach(t),$e=d(v),ee=i(v,"LI",{});var Uo=n(ee);et=a(Uo,"Waterfall project delivery and business-led manual testing timescales (yes, I know!)"),Uo.forEach(t),tt=d(v),te=i(v,"LI",{});var Co=n(te);ot=a(Co,"Azure DevOps hosted git repositories"),Co.forEach(t),it=d(v),oe=i(v,"LI",{});var Mo=n(oe);nt=a(Mo,"Undecided repository structure/ branching strategy/ deployment mechanism and little time to implement"),Mo.forEach(t),v.forEach(t),De=d(l),C=i(l,"H2",{});var Ho=n(C);lt=a(Ho,"Requirement consideration"),Ho.forEach(t),Ue=d(l),u=i(l,"UL",{});var b=n(u);M=i(b,"LI",{});var ao=n(M);rt=a(ao,"common upgrade mechanism for all products (1 product == 1 website == 1 project == 1 team)"),ie=i(ao,"UL",{});var Oo=n(ie);ne=i(Oo,"LI",{});var Wo=n(ne);at=a(Wo,"choose monorepo - this way only one version of the solution needs upgrading"),Wo.forEach(t),Oo.forEach(t),ao.forEach(t),st=d(b),H=i(b,"LI",{});var so=n(H);dt=a(so,"Independent development of different products"),I=i(so,"UL",{});var He=n(I);le=i(He,"LI",{});var qo=n(le);ct=a(qo,"use git branches to keep products separate without the need for synchronous communication between teams"),qo.forEach(t),ft=d(He),re=i(He,"LI",{});var zo=n(re);ht=a(zo,"standardise where possible for a consistent history and to aid centralised governance"),zo.forEach(t),He.forEach(t),so.forEach(t),ut=d(b),O=i(b,"LI",{});var co=n(O);pt=a(co,"Independent deployment of different products to the same environment"),L=i(co,"UL",{});var Oe=n(L);ae=i(Oe,"LI",{});var Ao=n(ae);mt=a(Ao,"partial deployments from independent pipelines/branches proved too difficult to manage"),Ao.forEach(t),vt=d(Oe),se=i(Oe,"LI",{});var Fo=n(se);bt=a(Fo,"merging both products to a common branch and deploying using a master pipeline is more reliable (if merge conflicts can be handled)"),Fo.forEach(t),Oe.forEach(t),co.forEach(t),gt=d(b),W=i(b,"LI",{});var fo=n(W);wt=a(fo,"Decoupled products which can be deployed in different orders to different environments"),de=i(fo,"UL",{});var No=n(de);ce=i(No,"LI",{});var Bo=n(ce);yt=a(Bo,"we need to merge products together for deployment but must not couple, so don’t pull code down from this “environment” branch"),Bo.forEach(t),No.forEach(t),fo.forEach(t),Et=d(b),q=i(b,"LI",{});var ho=n(q);_t=a(ho,"With all of these independently developed branch merging together we need to avoid merge conflicts"),fe=i(ho,"UL",{});var Ro=n(fe);he=i(Ro,"LI",{});var Po=n(he);It=a(Po,"identify the shared elements and see how best to manage each"),Po.forEach(t),Ro.forEach(t),ho.forEach(t),b.forEach(t),Ce=d(l),z=i(l,"H2",{});var Vo=n(z);Lt=a(Vo,"The solution"),Vo.forEach(t),Me=d(l),p=i(l,"UL",{});var g=n(p);A=i(g,"LI",{});var uo=n(A);kt=a(uo,"Deployment through Azure DevOps pipelines"),k=i(uo,"UL",{});var We=n(k);ue=i(We,"LI",{});var Qo=n(ue);xt=a(Qo,"yaml release pipelines provide better audit trail"),Qo.forEach(t),St=d(We),pe=i(We,"LI",{});var Go=n(pe);jt=a(Go,"entire solution built and deployed together, ensuring that all products build when combined"),Go.forEach(t),We.forEach(t),uo.forEach(t),Tt=d(g),F=i(g,"LI",{});var po=n(F);Dt=a(po,"Environment branches used to join different products together for deployment"),x=i(po,"UL",{});var qe=n(x);N=i(qe,"LI",{});var mo=n(N);me=i(mo,"EM",{});var Jo=n(me);Ut=a(Jo,"never"),Jo.forEach(t),Ct=a(mo," merge these back down into product branches to avoid coupling."),mo.forEach(t),Mt=d(qe),ve=i(qe,"LI",{});var Ko=n(ve);Ht=a(Ko,"only release branches ever merged (PR) to environment branches. This ensures that any environment contains a known version of each product."),Ko.forEach(t),qe.forEach(t),po.forEach(t),Ot=d(g),B=i(g,"LI",{});var vo=n(B);Wt=a(vo,"Maintain a separate develop branch for each product, for the lifetime of a project"),S=i(vo,"UL",{});var ze=n(S);be=i(ze,"LI",{});var Xo=n(be);qt=a(Xo,"these branches based off a root master/main and should be pulled down regularly as usual."),Xo.forEach(t),zt=d(ze),ge=i(ze,"LI",{});var Yo=n(ge);At=a(Yo,"development can loosely follow a git-flow process from here, features and fixes to the relevant develop branch, hotfixes to master"),Yo.forEach(t),ze.forEach(t),vo.forEach(t),Ft=d(g),we=i(g,"LI",{});var Zo=n(we);Nt=a(Zo,"Short-lived pieces of work can be based off master as hotfixes"),Zo.forEach(t),Bt=d(g),R=i(g,"LI",{});var bo=n(R);Rt=a(bo,"Do not change shared files within projects if possible, communicate the changes across teams if not"),m=i(bo,"UL",{});var w=n(m);_=i(w,"LI",{});var ke=n(_);ye=i(ke,"CODE",{});var $o=n(ye);Pt=a($o,"*.csproj"),$o.forEach(t),Vt=a(ke," project files - .NET Framework lists specific files, which causes many merge conflicts."),Qt=i(ke,"BR",{}),Gt=a(ke,`
Use wildcards to avoid ever having to change this file, this is possible because Sitefinity is a consistent framework, use hotfix for adding new patterns.`),ke.forEach(t),Jt=d(w),P=i(w,"LI",{});var go=n(P);Ee=i(go,"CODE",{});var ei=n(Ee);Kt=a(ei,"*.yml"),ei.forEach(t),Xt=a(go," pipelines - treat these as hotfixes, add check for presence of project before attempting to build"),go.forEach(t),Yt=d(w),V=i(w,"LI",{});var wo=n(V);_e=i(wo,"CODE",{});var ti=n(_e);Zt=a(ti,"Web.config"),ti.forEach(t),$t=a(wo," + transformations - don’t make breaking changes, add redirect rules, new config values etc as hotfixes"),wo.forEach(t),eo=d(w),Q=i(w,"LI",{});var yo=n(Q);Ie=i(yo,"CODE",{});var oi=n(Ie);to=a(oi,"*Config.config"),oi.forEach(t),oo=a(yo," + transformations - Sitefinity configuration - don’t make breaking changes, treat changes as hotfixes"),yo.forEach(t),io=d(w),G=i(w,"LI",{});var Eo=n(G);Le=i(Eo,"CODE",{});var ii=n(Le);no=a(ii,"Sitefinity.lic"),ii.forEach(t),lo=a(Eo," licence file - treat as hotfix"),Eo.forEach(t),w.forEach(t),bo.forEach(t),g.forEach(t)},m(l,c){f(l,E,c),e(E,Ae),f(l,xe,c),f(l,j,c),e(j,Fe),f(l,Se,c),f(l,T,c),e(T,Ne),f(l,je,c),f(l,D,c),e(D,Be),f(l,Te,c),f(l,h,c),e(h,K),e(K,Re),e(h,Pe),e(h,U),e(U,Ve),e(U,y),e(y,X),e(X,Qe),e(y,Ge),e(y,Y),e(Y,Je),e(y,Ke),e(y,Z),e(Z,Xe),e(h,Ye),e(h,$),e($,Ze),e(h,$e),e(h,ee),e(ee,et),e(h,tt),e(h,te),e(te,ot),e(h,it),e(h,oe),e(oe,nt),f(l,De,c),f(l,C,c),e(C,lt),f(l,Ue,c),f(l,u,c),e(u,M),e(M,rt),e(M,ie),e(ie,ne),e(ne,at),e(u,st),e(u,H),e(H,dt),e(H,I),e(I,le),e(le,ct),e(I,ft),e(I,re),e(re,ht),e(u,ut),e(u,O),e(O,pt),e(O,L),e(L,ae),e(ae,mt),e(L,vt),e(L,se),e(se,bt),e(u,gt),e(u,W),e(W,wt),e(W,de),e(de,ce),e(ce,yt),e(u,Et),e(u,q),e(q,_t),e(q,fe),e(fe,he),e(he,It),f(l,Ce,c),f(l,z,c),e(z,Lt),f(l,Me,c),f(l,p,c),e(p,A),e(A,kt),e(A,k),e(k,ue),e(ue,xt),e(k,St),e(k,pe),e(pe,jt),e(p,Tt),e(p,F),e(F,Dt),e(F,x),e(x,N),e(N,me),e(me,Ut),e(N,Ct),e(x,Mt),e(x,ve),e(ve,Ht),e(p,Ot),e(p,B),e(B,Wt),e(B,S),e(S,be),e(be,qt),e(S,zt),e(S,ge),e(ge,At),e(p,Ft),e(p,we),e(we,Nt),e(p,Bt),e(p,R),e(R,Rt),e(R,m),e(m,_),e(_,ye),e(ye,Pt),e(_,Vt),e(_,Qt),e(_,Gt),e(m,Jt),e(m,P),e(P,Ee),e(Ee,Kt),e(P,Xt),e(m,Yt),e(m,V),e(V,_e),e(_e,Zt),e(V,$t),e(m,eo),e(m,Q),e(Q,Ie),e(Ie,to),e(Q,oo),e(m,io),e(m,G),e(G,Le),e(Le,no),e(G,lo)},p:_o,i:_o,o:_o,d(l){l&&t(E),l&&t(xe),l&&t(j),l&&t(Se),l&&t(T),l&&t(je),l&&t(D),l&&t(Te),l&&t(h),l&&t(De),l&&t(C),l&&t(Ue),l&&t(u),l&&t(Ce),l&&t(z),l&&t(Me),l&&t(p)}}}class ci extends li{constructor(E){super(),ri(this,E,null,si,ai,{})}}export{ci as default};
