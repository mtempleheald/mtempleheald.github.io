import{a as q,t as S}from"../chunks/disclose-version.1SaWgZ9i.js";import"../chunks/legacy.8a7pGasK.js";import{s as o,f as k,i as e,r as t,g as r}from"../chunks/runtime.B66Dd-K4.js";import{h as i}from"../chunks/html.DcSxObny.js";var I=S(`<h1>Publish Database from ERD</h1> <p>I’m focusing here only on a relational database, typically a suitable choice for my use cases.<br> I often find that blogs/tutorials/demos always skip over the data aspect of solutions.<br> In my experience managing code is easy, managing data is hard.  Unless your data is transient in nature database changes require careful thought.</p> <p>My key requirements in an effective data design strategy are:</p> <ol><li><strong>Visualisation</strong> - I want to see an ERD or something similar, without this understanding a non-trivial database is going to be hard.<br> This needs to be versioned with the code, which rules out Visio and other binary representations.</li> <li><strong>Automation</strong> - The ERD and the production database should be linked via automated means.<br> Out-of-date documentation is sometimes worse than no documentation at all.<br> This rules out EF Core migrations (even if not using EF Core for production code).</li> <li><strong>Testability</strong> - Not so much a feature of the database, but I need to know that DB changes do not break things.<br> This means that integration tests must use the real database, on the same version as production, also during local dev, which leads me towards Docker.</li> <li><strong>Provider-agnostic</strong> - I have seen what vendor lock-in leads to and I don’t like it, we must maintain control of our applications.<br> In reality it is impossible to avoid this completely, but simple things like adhering to <a href="https://learnsql.com/blog/history-of-sql-standards/" rel="nofollow">SQL Standards</a> can help reduce the impact of migration.  I only want tables, indexes, constraints and possibly views, all logic will be in the application code.
This requirement rules out SSDT and <a href="https://github.com/microsoft/DacFx" rel="nofollow">DACPAC</a> deployment which is great, but only for SQL Server.</li> <li><strong>Maintainability</strong> - the solution needs to be simple to use in the medium to long term, though not necessarily simple to set up.</li></ol> <p>This mini project is something I’ve been meaning to do for years, since I built an Oracle DB deployment tool in Go and subsequently discovered DACPAC deployment in SQL Server.</p> <h2>Visualisation</h2> <p>I considered various options, including Microsoft Visio, <a href="https://mermaid.js.org/syntax/entityRelationshipDiagram.html" rel="nofollow">Mermaid</a>, <a href="https://dbdiagram.io/home/" rel="nofollow">dbdiagram.io</a>, <a href="https://structurizr.com/dsl?example=getting-started" rel="nofollow">Structurizr</a> to generate Mermaid diagrams, but eventually settled on <a href="https://marketplace.visualstudio.com/items?itemName=dineug.vuerd-vscode" rel="nofollow">ERD Editor</a> for VS Code.<br> I came to this decision because:</p> <ul><li>It is free & open source, so even if it was taken offline and destroyed I could invest some time and recover to my forked version</li> <li>It is offline, meaning that any sensitive data models are kept secure</li> <li>It is stored in text/json format, not binary, which makes version control in git tenable</li> <li>It has a feature to output liquibase changelogs built in</li></ul> <h2>Automation</h2> <p>Most DB automation tools are either prohibitively expensive, or vendor-specific.<br> I considered various options for automation, including:</p> <ul><li>Enhancing my old Go based solution for Oracle DBs, but I don’t have the code, only the design principles, so effectively this would be a fresh start.</li> <li><a href="https://learn.microsoft.com/en-us/sql/ssdt/extract-publish-and-register-dacpac-files?view=sql-server-ver16" rel="nofollow">SSDT (DACPAC publish)</a>, but this is SQL Server specific.</li> <li><a href="https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/?tabs=dotnet-core-cli" rel="nofollow">EF Migrations</a>, but this doesn’t work with visualisation tools AFAIK and I don’t want to be tied to EF Core, since it is .NET only.</li> <li><a href="https://www.red-gate.com/solutions/need/automate" rel="nofollow">Redgate Tools</a> but I assume this is too expensive since they don’t list the price on their website.</li> <li><a href="https://fluentmigrator.github.io" rel="nofollow">Fluent Migrator</a> but again this is .NET-specific, I don’t see a benefit over EF Core.</li> <li><a href="https://github.com/chucknorris/roundhouse/wiki" rel="nofollow">Roundhouse</a> but again this is .NET-specific, it also seems to be poorly maintained although I do like the convention-over-configuration approach at a glance</li></ul> <p>I eventually settled on <a href="https://www.liquibase.com/download" rel="nofollow">Liquibase</a> because it has a free and open source option (Apache-2.0 licensed), supports Docker, is clearly built to support CI/CD with documented <a href="https://docs.liquibase.com/workflows/liquibase-community/home.html" rel="nofollow">Open Source Workflows</a> and, crucially, it works with the visualisation tool I’ve selected.</p> <h2>Testability</h2> <p>The prompt for this mini-project was the discovery of <a href="https://github.com/testcontainers" rel="nofollow">Testcontainers</a> (via Nick Chapsas on Youtube).<br> This allows you to spin up a throwaway docker container, or collection of, just for the lifetime of the test(s).<br> This is not a substitute for unit testing since it will be significantly slower, but it is a better solution than testing with in-memory databases, which may have subtle differences in behaviour to the production database.</p> <h2>The solution</h2> <h3>Initial setup</h3> <ol><li>Install Docker (and optionally Docker Desktop, if licencing allows), examples below are unix images on Windows.</li> <li>Run SQL instance (example is MSSQL) for any manual testing and to prove scripts<br> <code>docker run --name "mssql_manual_test" -e "ACCEPT_EULA=Y" -e "MSSQL_SA_PASSWORD=yourStrong(!)Password" -p 1433:1433 -d mcr.microsoft.com/mssql/server:2022-latest</code></li> <li>Get latest liquibase image <code>docker pull liquibase/liquibase</code></li> <li>Install VS Code extension “ERD Editor” (vuerd)</li> <li>Create an ERD file <code>&lt;name&gt;.vuerd.json</code> within the project/solution/workspace, open this in VS Code and it should automatically load the editor.</li> <li>Create a DB model, be sure not to deselect Postgres as the output regardless of target DB type, required for Liquibase support<br> Be careful here to use appropriate data types for the target environment, <a href="https://github.com/dineug/erd-editor/blob/master/packages/sql-ddl-parser/src/SQL_DDL_Test_Case.md" rel="nofollow">ERD Editor supported types</a>.<br> The tool is clever enough to convert from <code>uuid</code> to <code>uniqueidentifier</code>, but not clever enough to convert from <code>varchar</code> to <code>varchar2</code> for example and certainly not when lengths are included (which they need to be since the default is 1 character).<br> Effectively I’d advise making multiple DB models if supporting multiple DB providers, but decide which is master, copy/paste, find/replace in JSON files to keep multiple versions in sync and versioned together (this is why models should be stored in text format).</li> <li>Generate a Liquibase changeset by right clicking the model and selecting Export > Liquibase<br> Use the naming convention <em>liquibase-change-###</em>, 999 DB changes should be enough for most projects.<br> Liquibase uses the id, author and filename to track changes - <a href="https://www.liquibase.com/how-liquibase-works" rel="nofollow">How Liquibase works</a><br> Keep the changelogs alongside the ERD model in source code, this lets ERD Editor load older changelogs to guarantee correct generation of new changelogs.<br> To apply multiple chainsets automatically, which we will need for automation, it is necessary to manually configure a master changelog <code>liquibase-change.xml</code>.</li> <li>Configure liquibase using a <em>liquibase.properties</em> file in the same folder: <pre class="language-undefined"><!></pre> This example is using the defaults for a <a href="https://hub.docker.com/_/microsoft-mssql-server" rel="nofollow">SQL Server docker</a> container, although the <a href="https://docs.liquibase.com/workflows/liquibase-community/using-liquibase-and-docker.html" rel="nofollow">Liquibase recommendation</a> is to pass these as arguments.  Passing by argument is also required for running multiple test sets in parallel since only one Docker container at a time can respond on a given port, even if we reuse credentials for testing, so this defaultsFile is kept just to simplify any manual test processes locally.<br> We require <code>encrypt=true and trustServerCertificate=true</code> to resolve firewall and SSL errors respectively, encountered whilst applying test changeset.</li> <li>We can now run liquibase commands, e.g. help<br> <code>docker run --rm --net=host -v "C:\\Path\\To\\Folder\\Containing\\changelogs":/liquibase/changelog liquibase/liquibase --defaultsFile=/liquibase/changelog/liquibase.properties --help</code><br> <code>--rm</code> ensures that the docker container is removed after completion of the script (see debugging)<br> <code>-net=host</code> ensures that the liquibase container can talk outside of the Docker bridge network (e.g. to connect to a Docker hosted DB).  In hindsight it is better to use internal network alias on the SQL container to connect from liquibase.<br> <code>-v</code> maps our local folder (Windows in this example) to the root of Liquibase’s changelog tree volume.<br> <code>--defaultsFile</code> tells Liquibase to use our properties file, which in turn tells it where to find changelogs and how to connect to the DB.<br> <code>--help</code> tells Liquibase to show us its help documentation, including available commands</li> <li>Debugging - if any of our commands fail we can investigate by launching Liquibase with a built-in in-memory DB:<br> <code>docker run --net=host -v "C:\\Path\\To\\Folder\\Containing\\changelogs":/liquibase/changelog liquibase/liquibase --defaultsFile=/liquibase/changelog/liquibase.properties init start-h2</code><br> In a separate command window find the running container using <code>docker ps</code><br> Jump inside it using <code>docker exec -it &lt;container_id&gt; bash</code>, you should see your files within <code>/changelog</code><br> From here you can run the same commands (everything after liquibase/liquibase) on top of liquibase directly, e.g. <code>liquibase --help</code><br> When done you will need to stop and remove the docker container yourself.</li> <li>Apply the changeset to the database manually (dbo schema is default for SQL Server)<br> <code>docker run --rm --net=host -v "C:\\Path\\To\\Folder\\Containing\\changelogs":/liquibase/changelog liquibase/liquibase --defaultsFile=/liquibase/changelog/liquibase.properties update --changelog-file=liquibase-change-001.xml --default-schema-name=dbo</code><br> If a changeset fails in dev, perhaps due to messing up constraints :|, and you wish to keep changesets clean before commit, you can truncate the table DATABASECHANGELOG which Liquibase manages.</li> <li>Check that this has worked as expected using SQL Server Object Explorer in Visual Studio or SQL browser of preference.</li></ol> <h3>Code changes</h3> <ol><li><p>Ensure that any DB code (repository) accesses the connection string via <code>IOptions</code> or better yet <code>IOptionsSnapshot</code> to allow live reloading of config.</p> <pre class="language-c#"><!></pre></li> <li><p>Create an xUnit IClassFixture <code>MsSqlTestFixture</code>, implementing <code>IAsyncLifetime</code> to ensure that it runs once per test class which uses it.<br> This class will:</p> <ol><li>Create a SQL container using the <code>ContainerBuilder</code>, mirroring the parameters above, although with a dynamically generated port.</li> <li>Wait for this to become responsive (by which I mean can accept SQL commands not just commands at the Docker/network layer)</li> <li>Spin up a Liquibase container to run a single command on this transient database - <code>update</code>, to apply all changes to get to the current version from an empty database and dispose it after completion.</li> <li>Expose SQL connection details via internal constants, for use by the test application.</li> <li>Dispose the SQL container and associated classes after test execution.</li></ol></li> <li><p>Create a custom <code>WebApplicationFactory</code> for testing, e.g. <code>TestWebApplicationFactory</code>.<br> This class will:</p> <ol><li>Start with the WebApplicationFactory used by the application itself.</li> <li>Replace real external dependencies in favour of managed stubs/fakes (out of scope of this document).</li> <li>Use constructor injection to load the SQL TestFixture which exposes the connection details of the transient database.</li> <li>Replace real connection strings with a connection string built from the SQL container settings.</li></ol> <pre class="language-c#"><!></pre></li> <li><p>Create a test class <code>MsSqlTests</code> which inherits <code>IClassFixture&lt;MsSqlTestFixture&gt;</code> and <code>IDisposable</code><br> In the constructor use the above classes to make the DB available to the tests:</p> <pre class="language-c#"><!></pre></li></ol> <h3>Issues</h3> <p>It takes some time to spin up a liquibase container, connect to a SQL database and apply migration scripts.<br> I found during exploration that whilst debugging the test everything was working as designed, however, whilst running the tests had completed (with failures) before the DB scripts had been executed.<br> It is possible to set a WaitStrategy on testcontainers to ensure that they are ready before moving on.<br> I had no luck getting this to work with liquibase, since it is not designed to stay up after the command is completed.<br> I’m sure there’s a better way, but my fix for this was to put a while loop in between starting and disposing the liquibase container.<br> This simply runs an appropriate query on the SQL container which indicates completion, then waits for a second before retrying, up to N times.</p> <h3>Next steps</h3> <p>The solution now works as intended (as long as you remember to start Docker first).<br> I simply need to complete the work now, in a more test driven fashion than I normally would.<br> Finally I need to automate integration testing on CICD pipelines.<br> All of the above is checked in to a private GitHub repo for now, I may make this public at some point.</p>`,1);function F(b){var l=I(),s=o(k(l),32),c=o(e(s),14),d=o(e(c),3),f=e(d);i(f,()=>`<code class="language-undefined">classpath: /liquibase/changelog
changeLogFile: changelog.xml
url: jdbc:sqlserver://localhost:1433;database=master;encrypt=true;trustServerCertificate=true
username: sa
password: yourStrong(!)Password
# liquibaseProLicenseKey=&lt;PASTE LB PRO LICENSE KEY HERE&gt;</code>`),t(d),r(9),t(c),r(8),t(s);var u=o(s,4),a=e(u),h=o(e(a),2),w=e(h);i(w,()=>`<code class="language-c#">public class ConnectionStringsOptions
&#123;
   public const string ConfigKey = &quot;ConnectionStrings&quot;;
   public string MyDb &#123; get; set; &#125; = string.Empty;
&#125;</code>`),t(h),t(a);var n=o(a,4),p=o(e(n),4),y=e(p);i(y,()=>`<code class="language-c#">public TestWebApplicationFactory(MsSqlTestFixture sqlTestFixture)
&#123;
 _connectionString = $&quot;Server=&#123;sqlTestFixture._msSqlcontainer.Hostname
     &#125;,&#123;sqlTestFixture._msSqlcontainer.GetMappedPublicPort(MsSqlTestFixture.MsSqlPort)
     &#125;;Database=&#123;MsSqlTestFixture.Database
     &#125;;User Id=&#123;MsSqlTestFixture.Username
     &#125;;Password=&#123;MsSqlTestFixture.Password
     &#125;;TrustServerCertificate=True&quot;;
&#125;

protected override IHost CreateHost(IHostBuilder builder)
&#123;
   builder.ConfigureServices(services =&gt; 
   &#123;
      services.Configure&lt;ConnectionStringsOptions&gt;(opts =&gt; &#123;
      opts.MyDb = _connectionString;
      &#125;);
   &#125;);
&#125;</code>`),t(p),t(n);var g=o(n,2),m=o(e(g),2),v=e(m);i(v,()=>`<code class="language-c#">public MsSqlTests(MsSqlTestFixture msSqlTestFixture)
&#123;
   _webApplicationFactory = new TestWebApplicationFactory&lt;Program&gt;(msSqlTestFixture);
   _httpClient = _webApplicationFactory.CreateClient(new WebApplicationFactoryClientOptions &#123;
     AllowAutoRedirect = false // Test first response
   &#125;);
&#125;
public void Dispose()
&#123;
   _webApplicationFactory.Dispose();
&#125;</code>`),t(m),t(g),t(u),r(8),q(b,l)}export{F as component};
