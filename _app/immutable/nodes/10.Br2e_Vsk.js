import{s as Qt,n as Ve}from"../chunks/scheduler.Cp24rM3s.js";import{S as Xt,i as Gt,e as n,s as o,c as s,k as a,a as r,g as i,d as l}from"../chunks/index.CkxK-9SL.js";function Jt(Bt){let u,Ye=`I recently read the <em>The Data Warehouse Toolkit (Second Edition)</em> before embarking on a project to implement a new data warehouse.<br/>
I recommend reading this book, it is clear, detailed and accessible, but here is a super succinct summary for my own benefit.`,le,f,Ze="Fact tables",ne,m,$e=`<li>few columns, many rows</li> <li>always at lowest level (granular) detail
<ul><li>lowest level of detail required for business reporting, not necessarily the lowest level grain held by the source system</li></ul></li> <li>typically try to avoid semi-additive facts (e.g. balance)</li> <li>always avoid to-date totals, not consistent with the grain</li> <li>try to avoid textual facts
<ul><li>tend to be filtered out into a separate dimension (mini dimension)</li></ul></li>`,se,d,et="Factless fact tables",ae,v,tt="<li>convenient representation of many-many relationships between dimensions, even if there is no obvious numeric fact at that level</li> <li>may wish to add artificial fact (always == 1) to clarify queries</li>",oe,h,it="Coverage tables",re,p,lt="<li>special form of factless fact table</li> <li>one row per dimension Cartesian product, regardless of occupation, flag to indicate available/ in use</li> <li>There is a data overhead involved in doing this so it is only for special uses</li>",ue,c,nt="Dimension tables",fe,C,st="<li>few rows, many columns</li> <li>denormalised extensively – few rows =&gt; small impact in size compared with performance improvements</li> <li>Avoid snowflaking (normalising of dimensions) – will slow queries</li> <li>Need surrogate key (SKey) to uniquely identify a row even if a suitable business key exists, future proofing</li> <li>Need getSKey function for each dim (based on natural key)</li> <li>Cater for null values using a “-1” entry</li> <li>Typically expect 5-15 dimensions per dimensional model</li>",me,x,at="Date dimension",de,y,ot="<li>1 row per day</li> <li>Day, week, month, quarter, year info on each line</li> <li>Easier filtering/ formatting than SQL date conversion functions</li> <li>The ONLY dimension with a meaningful key – in date order</li> <li>This predictability is important for partitioning, backups and restorations, whereby all rows relating to a date range should be partitioned together</li>",ve,b,rt="Data Modelling Approach",he,w,ut="<li>Separate ERD(s) into business processes &amp; model separately</li> <li>Many-many tables become facts</li> <li>Denormalise remaining tables – become dimensions</li> <li>Convert identifiers into meaningful data e.g. ‘M’ becomes ‘Male’</li> <li>Agree on these “conformed” dimensions and seek to reuse</li> <li>Likewise seek to use conformed facts with standard, meaningful attributes</li>",pe,L,ft="Maintaining the DW Bus Matrix",ce,H,mt="<li>Business process (data mart = set of closely-related fact tables) vs common dimensions. This is a very high level planning aid (p79)</li> <li>Enables coherent vision of DW architecture</li> <li>Can extend to include fact table/ granularity/ facts for full picture. This is more closely tied to the implementation phase (p321)</li>",Ce,T,dt="Conformed dimensions",xe,M,vt="<li>Agreed business nomenclature to avoid redundancy and inaccuracy</li> <li>Common columns are identical</li> <li>1 may have extra columns e.g. confidential information</li> <li>1 may have extra rows (subset of data) –be careful re. referential integrity</li>",ye,_,ht="Slowly Changing Dimensions (SCD)",be,k,pt=`<li>Type 1 – overwrite old version – lose history</li> <li>Type 2 – create new dim row – keep history but cannot look at both together</li> <li>Type 3 – consider 2 (or 3…) previous versions
<ul><li>require fact column for each version</li> <li>can compare versions as of date X</li></ul></li> <li>Combinations of the above</li>`,we,g,ct="Role-Playing dimensions",Le,U,Ct="<li>When need 2 dates on a table need 2 references to Date Dim.</li> <li>Cant refer to same table twice so use views instead</li> <li>Applicable to other dimensions but common with date dimension</li>",He,D,xt="Dimension Outriggers",Te,S,yt=`<li>Constitutes normalisation of dimensions – use sparingly</li> <li>Useful when dimensions of significantly differing grain and main dimension is large<br/>
e.g. customers + demographics (age, gender etc)</li> <li>Location is a valid candidate for an outrigger – can use GIS tools too</li>`,Me,q,bt="Degenerate dimensions",_e,j,wt=`<li>Number left in fact table without corresponding dim table.
Can be later expanded to a dimension if required (but use surrogate keys then!)
Can be grouped/ filtered in the meantime.</li> <li>If dimension contains similar numbers of rows to the fact table,
this may be a good candidate for a degenerate dimension</li>`,ke,E,Lt="Junk dimensions",ge,I,Ht="<li>Groups of typically low-cardinality flags</li> <li>may look like Cartesian product but with a surrogate key</li> <li>can be used to reduce the number of columns in a fact table, potentially space-saving.</li>",Ue,A,Tt="Mini dimensions",De,P,Mt="<li>Separate textual fact out from fact table into mini dimension.</li> <li>Enabled high-performance filtering of data</li>",Se,z,_t="Header/Line facts with different granularity",qe,F,kt="<li>Remove higher-level fact table by duplicating facts from the higher-level header fact row down to lower-level line fact row(s), much like dimension denormalisation</li> <li>Or maintain both tables at different granularity (only when necessary)</li>",je,N,gt="Real-Time Partitions",Ee,R,Ut="<li>Physically &amp; administratively separate “partition” (different tables) from the rest of the warehouse.</li> <li>Contains all activity since last standard ETL run, same structure as standard DW tables.</li>",Ie,W,Dt="Bridge tables (p164)",Ae,K,St="<li>For variable-depth hierarchies</li> <li>May contain parent skey, subsidiary skey, level, bottom flag, top flag</li> <li>Can create view new_fact = bridge + fact to hide complexity</li> <li>Combine with a weighting factor attribute on the bridge table, summed over the group it should always equal 1</li>",Pe,O,qt="Audit Dimension",ze,B,jt="<li>Source system, ETL version, confidences</li> <li>use skey to link to rows updated by that particular ETL run</li>",Fe,Q,Et="Keyword Outrigger Dimension",Ne,X,It="<li>Attribute such as ’\\UNIX\\LINUX\\SQL\\’ for skills for a person</li> <li>Can filter using LIKE ‘%\\SQL\\%’ (avoids complicated union views)</li>",Re,G,At="Superdimension (similar to junk dimension)",We,J,Pt=`<li>Combine 2 or more dimensions into a single dimension.<br/>
This is likely to be a Cartesian product and is suitable only for small date volumes</li> <li>E.g. flights – class flown != class purchased (up/downgrades), create superdimension with 9 rows (coach/business/first)^2</li>`,Ke,V,zt="Fact Dimension",Oe,Y,Ft="<li>For sparse fact tables, i.e. groups of attributes often empty</li> <li>separate these attribute groups into separate fact dimensions and link with surrogate key</li> <li>Allows us to keep fact table structure static, no new columns</li> <li>Very flexible but may expand too quickly if facts become less sparse</li> <li>may considerably complicate data access</li> <li>Type + content dimensions to handle heterogeneous products</li>",Be,Z,Nt="Late-arriving fact rows",Qe,$,Rt=`<li>For each dimension establish surrogate key based on natural key (plus SCD effective dates)</li> <li>insert into correct physical partition based on date</li> <li>If historical data cannot change (has been reported, though inaccurate)
then may need 2 sets of dates (operational/ booking)</li>`,Xe,ee,Wt="Late-arriving dimension rows (applied to slowly changing dimensions)",Ge,te,Kt="<li>Insert new row with new surrogate key</li> <li>Scan forwards from this date and correct later rows with same natural key</li> <li>Update all fact rows to correct surrogate key</li>",Je,ie,Ot=`The summary of traps to avoid on P326 is well worth reading too.<br/>
In order to improve performance of the ETL you can use a cyclic redundancy checksum (CRC) algorithm on dimension staging tables.<br/>
This is a more efficient way to determine if row has been updated than comparing each column.`;return{c(){u=n("p"),u.innerHTML=Ye,le=o(),f=n("h4"),f.textContent=Ze,ne=o(),m=n("ul"),m.innerHTML=$e,se=o(),d=n("h4"),d.textContent=et,ae=o(),v=n("ul"),v.innerHTML=tt,oe=o(),h=n("h4"),h.textContent=it,re=o(),p=n("ul"),p.innerHTML=lt,ue=o(),c=n("h4"),c.textContent=nt,fe=o(),C=n("ul"),C.innerHTML=st,me=o(),x=n("h4"),x.textContent=at,de=o(),y=n("ul"),y.innerHTML=ot,ve=o(),b=n("h4"),b.textContent=rt,he=o(),w=n("ul"),w.innerHTML=ut,pe=o(),L=n("h4"),L.textContent=ft,ce=o(),H=n("ul"),H.innerHTML=mt,Ce=o(),T=n("h4"),T.textContent=dt,xe=o(),M=n("ul"),M.innerHTML=vt,ye=o(),_=n("h4"),_.textContent=ht,be=o(),k=n("ul"),k.innerHTML=pt,we=o(),g=n("h4"),g.textContent=ct,Le=o(),U=n("ul"),U.innerHTML=Ct,He=o(),D=n("h4"),D.textContent=xt,Te=o(),S=n("ul"),S.innerHTML=yt,Me=o(),q=n("h4"),q.textContent=bt,_e=o(),j=n("ul"),j.innerHTML=wt,ke=o(),E=n("h4"),E.textContent=Lt,ge=o(),I=n("ul"),I.innerHTML=Ht,Ue=o(),A=n("h4"),A.textContent=Tt,De=o(),P=n("ul"),P.innerHTML=Mt,Se=o(),z=n("h4"),z.textContent=_t,qe=o(),F=n("ul"),F.innerHTML=kt,je=o(),N=n("h4"),N.textContent=gt,Ee=o(),R=n("ul"),R.innerHTML=Ut,Ie=o(),W=n("h4"),W.textContent=Dt,Ae=o(),K=n("ul"),K.innerHTML=St,Pe=o(),O=n("h4"),O.textContent=qt,ze=o(),B=n("ul"),B.innerHTML=jt,Fe=o(),Q=n("h4"),Q.textContent=Et,Ne=o(),X=n("ul"),X.innerHTML=It,Re=o(),G=n("h4"),G.textContent=At,We=o(),J=n("ul"),J.innerHTML=Pt,Ke=o(),V=n("h4"),V.textContent=zt,Oe=o(),Y=n("ul"),Y.innerHTML=Ft,Be=o(),Z=n("h4"),Z.textContent=Nt,Qe=o(),$=n("ul"),$.innerHTML=Rt,Xe=o(),ee=n("h4"),ee.textContent=Wt,Ge=o(),te=n("ul"),te.innerHTML=Kt,Je=o(),ie=n("p"),ie.innerHTML=Ot},l(e){u=s(e,"P",{"data-svelte-h":!0}),a(u)!=="svelte-11001so"&&(u.innerHTML=Ye),le=r(e),f=s(e,"H4",{"data-svelte-h":!0}),a(f)!=="svelte-1pavi83"&&(f.textContent=Ze),ne=r(e),m=s(e,"UL",{"data-svelte-h":!0}),a(m)!=="svelte-18okl6e"&&(m.innerHTML=$e),se=r(e),d=s(e,"H4",{"data-svelte-h":!0}),a(d)!=="svelte-1y08b0q"&&(d.textContent=et),ae=r(e),v=s(e,"UL",{"data-svelte-h":!0}),a(v)!=="svelte-hokn60"&&(v.innerHTML=tt),oe=r(e),h=s(e,"H4",{"data-svelte-h":!0}),a(h)!=="svelte-1v7ewrv"&&(h.textContent=it),re=r(e),p=s(e,"UL",{"data-svelte-h":!0}),a(p)!=="svelte-14johpx"&&(p.innerHTML=lt),ue=r(e),c=s(e,"H4",{"data-svelte-h":!0}),a(c)!=="svelte-1hkqtev"&&(c.textContent=nt),fe=r(e),C=s(e,"UL",{"data-svelte-h":!0}),a(C)!=="svelte-7njvs6"&&(C.innerHTML=st),me=r(e),x=s(e,"H4",{"data-svelte-h":!0}),a(x)!=="svelte-hq5oom"&&(x.textContent=at),de=r(e),y=s(e,"UL",{"data-svelte-h":!0}),a(y)!=="svelte-aagxsz"&&(y.innerHTML=ot),ve=r(e),b=s(e,"H4",{"data-svelte-h":!0}),a(b)!=="svelte-ca3i0j"&&(b.textContent=rt),he=r(e),w=s(e,"UL",{"data-svelte-h":!0}),a(w)!=="svelte-10ets5s"&&(w.innerHTML=ut),pe=r(e),L=s(e,"H4",{"data-svelte-h":!0}),a(L)!=="svelte-1v1rqgy"&&(L.textContent=ft),ce=r(e),H=s(e,"UL",{"data-svelte-h":!0}),a(H)!=="svelte-70p7nw"&&(H.innerHTML=mt),Ce=r(e),T=s(e,"H4",{"data-svelte-h":!0}),a(T)!=="svelte-1pfg0e"&&(T.textContent=dt),xe=r(e),M=s(e,"UL",{"data-svelte-h":!0}),a(M)!=="svelte-nsgcwr"&&(M.innerHTML=vt),ye=r(e),_=s(e,"H4",{"data-svelte-h":!0}),a(_)!=="svelte-pmct7p"&&(_.textContent=ht),be=r(e),k=s(e,"UL",{"data-svelte-h":!0}),a(k)!=="svelte-1boxx2y"&&(k.innerHTML=pt),we=r(e),g=s(e,"H4",{"data-svelte-h":!0}),a(g)!=="svelte-h7baau"&&(g.textContent=ct),Le=r(e),U=s(e,"UL",{"data-svelte-h":!0}),a(U)!=="svelte-1sh9ucq"&&(U.innerHTML=Ct),He=r(e),D=s(e,"H4",{"data-svelte-h":!0}),a(D)!=="svelte-1g1189r"&&(D.textContent=xt),Te=r(e),S=s(e,"UL",{"data-svelte-h":!0}),a(S)!=="svelte-15kjogp"&&(S.innerHTML=yt),Me=r(e),q=s(e,"H4",{"data-svelte-h":!0}),a(q)!=="svelte-7rsfp9"&&(q.textContent=bt),_e=r(e),j=s(e,"UL",{"data-svelte-h":!0}),a(j)!=="svelte-1op2r90"&&(j.innerHTML=wt),ke=r(e),E=s(e,"H4",{"data-svelte-h":!0}),a(E)!=="svelte-dh3u2j"&&(E.textContent=Lt),ge=r(e),I=s(e,"UL",{"data-svelte-h":!0}),a(I)!=="svelte-bk3gh7"&&(I.innerHTML=Ht),Ue=r(e),A=s(e,"H4",{"data-svelte-h":!0}),a(A)!=="svelte-3rjv6u"&&(A.textContent=Tt),De=r(e),P=s(e,"UL",{"data-svelte-h":!0}),a(P)!=="svelte-86l0se"&&(P.innerHTML=Mt),Se=r(e),z=s(e,"H4",{"data-svelte-h":!0}),a(z)!=="svelte-38pfcm"&&(z.textContent=_t),qe=r(e),F=s(e,"UL",{"data-svelte-h":!0}),a(F)!=="svelte-14lb00a"&&(F.innerHTML=kt),je=r(e),N=s(e,"H4",{"data-svelte-h":!0}),a(N)!=="svelte-1hbl247"&&(N.textContent=gt),Ee=r(e),R=s(e,"UL",{"data-svelte-h":!0}),a(R)!=="svelte-mz9xci"&&(R.innerHTML=Ut),Ie=r(e),W=s(e,"H4",{"data-svelte-h":!0}),a(W)!=="svelte-37dcow"&&(W.textContent=Dt),Ae=r(e),K=s(e,"UL",{"data-svelte-h":!0}),a(K)!=="svelte-1t62t39"&&(K.innerHTML=St),Pe=r(e),O=s(e,"H4",{"data-svelte-h":!0}),a(O)!=="svelte-5yngyj"&&(O.textContent=qt),ze=r(e),B=s(e,"UL",{"data-svelte-h":!0}),a(B)!=="svelte-1eml1c6"&&(B.innerHTML=jt),Fe=r(e),Q=s(e,"H4",{"data-svelte-h":!0}),a(Q)!=="svelte-1or4f47"&&(Q.textContent=Et),Ne=r(e),X=s(e,"UL",{"data-svelte-h":!0}),a(X)!=="svelte-tzjbpg"&&(X.innerHTML=It),Re=r(e),G=s(e,"H4",{"data-svelte-h":!0}),a(G)!=="svelte-1lif4bw"&&(G.textContent=At),We=r(e),J=s(e,"UL",{"data-svelte-h":!0}),a(J)!=="svelte-8o2zf4"&&(J.innerHTML=Pt),Ke=r(e),V=s(e,"H4",{"data-svelte-h":!0}),a(V)!=="svelte-v8z5c4"&&(V.textContent=zt),Oe=r(e),Y=s(e,"UL",{"data-svelte-h":!0}),a(Y)!=="svelte-tgvyn"&&(Y.innerHTML=Ft),Be=r(e),Z=s(e,"H4",{"data-svelte-h":!0}),a(Z)!=="svelte-wnoy72"&&(Z.textContent=Nt),Qe=r(e),$=s(e,"UL",{"data-svelte-h":!0}),a($)!=="svelte-1ib5kew"&&($.innerHTML=Rt),Xe=r(e),ee=s(e,"H4",{"data-svelte-h":!0}),a(ee)!=="svelte-sgwo6d"&&(ee.textContent=Wt),Ge=r(e),te=s(e,"UL",{"data-svelte-h":!0}),a(te)!=="svelte-fjk3xp"&&(te.innerHTML=Kt),Je=r(e),ie=s(e,"P",{"data-svelte-h":!0}),a(ie)!=="svelte-7ckog6"&&(ie.innerHTML=Ot)},m(e,t){i(e,u,t),i(e,le,t),i(e,f,t),i(e,ne,t),i(e,m,t),i(e,se,t),i(e,d,t),i(e,ae,t),i(e,v,t),i(e,oe,t),i(e,h,t),i(e,re,t),i(e,p,t),i(e,ue,t),i(e,c,t),i(e,fe,t),i(e,C,t),i(e,me,t),i(e,x,t),i(e,de,t),i(e,y,t),i(e,ve,t),i(e,b,t),i(e,he,t),i(e,w,t),i(e,pe,t),i(e,L,t),i(e,ce,t),i(e,H,t),i(e,Ce,t),i(e,T,t),i(e,xe,t),i(e,M,t),i(e,ye,t),i(e,_,t),i(e,be,t),i(e,k,t),i(e,we,t),i(e,g,t),i(e,Le,t),i(e,U,t),i(e,He,t),i(e,D,t),i(e,Te,t),i(e,S,t),i(e,Me,t),i(e,q,t),i(e,_e,t),i(e,j,t),i(e,ke,t),i(e,E,t),i(e,ge,t),i(e,I,t),i(e,Ue,t),i(e,A,t),i(e,De,t),i(e,P,t),i(e,Se,t),i(e,z,t),i(e,qe,t),i(e,F,t),i(e,je,t),i(e,N,t),i(e,Ee,t),i(e,R,t),i(e,Ie,t),i(e,W,t),i(e,Ae,t),i(e,K,t),i(e,Pe,t),i(e,O,t),i(e,ze,t),i(e,B,t),i(e,Fe,t),i(e,Q,t),i(e,Ne,t),i(e,X,t),i(e,Re,t),i(e,G,t),i(e,We,t),i(e,J,t),i(e,Ke,t),i(e,V,t),i(e,Oe,t),i(e,Y,t),i(e,Be,t),i(e,Z,t),i(e,Qe,t),i(e,$,t),i(e,Xe,t),i(e,ee,t),i(e,Ge,t),i(e,te,t),i(e,Je,t),i(e,ie,t)},p:Ve,i:Ve,o:Ve,d(e){e&&(l(u),l(le),l(f),l(ne),l(m),l(se),l(d),l(ae),l(v),l(oe),l(h),l(re),l(p),l(ue),l(c),l(fe),l(C),l(me),l(x),l(de),l(y),l(ve),l(b),l(he),l(w),l(pe),l(L),l(ce),l(H),l(Ce),l(T),l(xe),l(M),l(ye),l(_),l(be),l(k),l(we),l(g),l(Le),l(U),l(He),l(D),l(Te),l(S),l(Me),l(q),l(_e),l(j),l(ke),l(E),l(ge),l(I),l(Ue),l(A),l(De),l(P),l(Se),l(z),l(qe),l(F),l(je),l(N),l(Ee),l(R),l(Ie),l(W),l(Ae),l(K),l(Pe),l(O),l(ze),l(B),l(Fe),l(Q),l(Ne),l(X),l(Re),l(G),l(We),l(J),l(Ke),l(V),l(Oe),l(Y),l(Be),l(Z),l(Qe),l($),l(Xe),l(ee),l(Ge),l(te),l(Je),l(ie))}}}class Zt extends Xt{constructor(u){super(),Gt(this,u,null,Jt,Qt,{})}}export{Zt as component};
