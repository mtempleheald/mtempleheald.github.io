<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="/favicon.ico" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />

		<meta http-equiv="content-security-policy" content="">
	<link rel="stylesheet" href="/_app/assets/pages/__layout.svelte-711b4112.css">
	<link rel="modulepreload" href="/_app/start-e82316e2.js">
	<link rel="modulepreload" href="/_app/chunks/vendor-5ca848cc.js">
	<link rel="modulepreload" href="/_app/pages/__layout.svelte-8da8bfc2.js">
	<link rel="modulepreload" href="/_app/pages/blog/_slug_.svelte-db98abb9.js">
	</head>
	<body>
		<div>



<div class="svelte-1lrvsco"><header><h1 class="svelte-1lrvsco">Mark Temple-Heald</h1>
  <h2 class="svelte-1lrvsco">the right tool for the job</h2></header>

<nav class="svelte-r02kv1"><ul class="svelte-r02kv1"><li class="svelte-r02kv1"><a href="/" class="navAnchor">Home</a></li>
    <li class="svelte-r02kv1"><a href="/blog" class="navAnchor">Blog</a></li>
    <li class="svelte-r02kv1"><a href="/topic" class="navAnchor">Topic</a></li>
    <li class="svelte-r02kv1"><a href="/about" class="navAnchor">About</a></li></ul>
</nav>
</div>

<main class="svelte-lv7236"><!-- HTML_TAG_START --><h1>Web Journey without JavaScript</h1>An exploration into developing a full web journey without JavaScript.<br />I'm not overly keen on JavaScript (or dynamic languages in general), but the true motivation here is layering, specifically the repetition of business logic in 2 places.<h2>Vision</h2><ul><li>Want all business logic to reside <em>only</em> on the server, since we can't trust anything handled client side.</li><li>Need interactivity in the browser, else it will be a poor user experience, but this needs to be data-driven and not contain business logic.</li></ul><h2>Initial thoughts</h2>WebAssembly is now available as an alternative to JavaScript in the browser, for many use cases.  There are limits, most notably the inability to interact directly with the DOM.
So the solution will require some JavaScript plumbing.<br />The JavaScript elements should be limited to context-agnostic data-driven validation/display toggling, using a library such as <a href="https://validatejs.org/">validate.js</a>.<h2>Design principles</h2><ul><li>JavaScript is a pre-requisite, so beyond showing a nice message don't worry about progressive enhancement.</li><li>We can share code front and backend (if that makes sense) but we must write it only once</li><li>All code must be testable</li><li>The application must be responsive with no significant latency<h2>Solution design</h2></li></ul><br />Easiest to think about this in terms of interface boundaries<br />| JavaScript        | WASM Frontend | Backend        | Notes                                    |
| ----------------- | ------------- | -------------- | ---------------------------------------- |
| onLoad setup      | setupForm     | getQuestionSet | grab data from backend to generate form  |
| onChange validate | -             | -              | perform simple validation in front end   |
| onChange update   | updateX       | -              | update central WASM model as they change |
| onSubmit validate | validateX     | -              | perform complex multifield validation    |
| onSubmit submit   | submitX       | submitX        | ensure validated, pass to backend        |<h3>QuestionSet data structure</h3>There should be sufficient information in here for both display and simple validation.<br /><pre class="code json"><code class="language-json">{
    &quot;question-set&quot;: &quot;string&quot;, // questionset identifier, there may be many in a single journey
    &quot;questions&quot;: [
        {
            &quot;type&quot;: &quot;string&quot;, // text | number | datetime | select | radio | ...
            &quot;name&quot;: &quot;string&quot;, // form control name
            &quot;label&quot;: &quot;string&quot;, // form control label
            &quot;default&quot;: &quot;string&quot;, // maps to (value | checked) property
            &quot;helptext&quot;: &quot;string&quot;, // markdown tooltip or subtext, depending on cosmetic choices
            &quot;valid-required&quot;: &quot;boolean&quot;, // maps to required property
            &quot;valid-max&quot;: &quot;integer&quot;, // maps to (max | maxLength) property
            &quot;valid-min&quot;: &quot;integer&quot;, // maps to (min | minLength) property
            &quot;valid-regexp&quot;: &quot;string&quot;, // maps to pattern property
            &quot;valid-errmsg&quot;: &quot;string&quot;, // error message to go with regexp validation
            &quot;data-source&quot;: &quot;string&quot;, // data-source attribute used for reference data
            &quot;pre-markdown&quot;: &quot;string&quot;, // markdown to render before the question
            &quot;post-markdown&quot;: &quot;string&quot;, // markdown to render after the question
            &quot;display-if-parent&quot;: &quot;string&quot;, // data-parent attribute - hide until parent condition met
            &quot;display-if-value&quot;: &quot;string&quot; // data-parent-val attribute
        },
        // ...
    ]
}</code></pre><h3>Validate & submit</h3><ul><li>Should have already performed simple validation in the browser</li><li>Should already have all required values from the questionset submitted during navigation</li><li>Assume neither of these things are true, validate in full.  </li></ul>
  This can mean running validation twice, but the client side stuff was for the user's benefit and we didn't write it by hand for this journey, the underlying data which drives it was generated in the backend.<br /><ol><li>All fields in questionset answered, click submit button.</li><li>JavaScript onSubmit() code calls WebAssembly ProcessQuestionSet() which returns error string or "".</li><li>JavaScript either displays errors or navigates onwards (can preload next page while waiting for response)</li><li>Wasm applies business logic and passes data on for further processing if required</li></ol><br /><ul><li>Page URLs and navigation are the domain of the JS.</li><li>Data, session and persistence are the domain of the backend & wasm frontend</li></ul>
These 2 aspects aren't entirely independent...<br />If we choose to go down the SPA route then we can consider the WASM memory as the session data.<br />We also have the option here to break up the questionSet into as many or as few chunks as we like.
We can even combine questionSets within the same business logic, since all exist in session data together.<br />If we choose to go down the multipage route then we need to call out to a persistence layer in between pages.
This persistence layer could be in the browser (localStorage/sessionStorage) or backend via an async API call, either way this should be handled by WASM.
Any time we need to look at data spanning questionSets (pages in this scenario) we need to also perform data retrieval steps to pull in data from other pages, this starts to feel messy so SPA seems preferable all things considered.<h3>Conclusion</h3><ul><li>Layer separation is clear and there is no code duplication.</li><li>Browser-based data-annotation-driven validation is proven and well known</li><li>The practicalities of interop for questionSet submission to be proven, can't add too much latency.</li><li>WASM to backend APIs via REST or gRPC to be considered - not clear on security in WASM </li></ul><!-- HTML_TAG_END --></main>


<footer class="svelte-14g1sgx"><p>This is my site, there are many like it but this one is mine.</p>
  <p>If you don&#39;t like it, you know where the close button is.</p>
  <a href="https://www.linkedin.com/in/mtempleheald" target="_blank" class="svelte-14g1sgx">Mark Temple-Heald</a>
  <a href="https://mtempleheald.github.io" target="_blank" class="svelte-14g1sgx">Home</a>
  <a href="https://github.com/mtempleheald" target="_blank" class="svelte-14g1sgx">GitHub</a>
  <p>Mindful meanderings manifest more manageable machinations.
    Manoeuvring murky multifaceted modernism means meticulously managing many mistakes, misconceptions, misunderstandings.
    Measured multipronged musings, mechanical movements, may maximise meritorious magnificence.
  </p>
</footer>


		<script type="module" data-hydrate="15e6ueq">
		import { start } from "/_app/start-e82316e2.js";
		start({
			target: document.querySelector('[data-hydrate="15e6ueq"]').parentNode,
			paths: {"base":"","assets":""},
			session: {},
			route: true,
			spa: false,
			trailing_slash: "never",
			hydrate: {
				status: 200,
				error: null,
				nodes: [
					import("/_app/pages/__layout.svelte-8da8bfc2.js"),
						import("/_app/pages/blog/_slug_.svelte-db98abb9.js")
				],
				url: new URL("http://sveltekit-prerender/blog/2021-03-08-Web-Journey-without-JavaScript"),
				params: {slug:"2021-03-08-Web-Journey-without-JavaScript"}
			}
		});
	</script><script type="application/json" data-type="svelte-data" data-url="/api/blogs/2021-03-08-Web-Journey-without-JavaScript">{"status":200,"statusText":"","headers":{"content-type":"text/plain;charset=UTF-8"},"body":"# Web Journey without JavaScript\n\nAn exploration into developing a full web journey without JavaScript.  \n\nI'm not overly keen on JavaScript (or dynamic languages in general), but the true motivation here is layering, specifically the repetition of business logic in 2 places.\n\n## Vision\n\n- Want all business logic to reside _only_ on the server, since we can't trust anything handled client side.\n- Need interactivity in the browser, else it will be a poor user experience, but this needs to be data-driven and not contain business logic.\n\n## Initial thoughts\n\nWebAssembly is now available as an alternative to JavaScript in the browser, for many use cases.  There are limits, most notably the inability to interact directly with the DOM.\nSo the solution will require some JavaScript plumbing.\n\nThe JavaScript elements should be limited to context-agnostic data-driven validation\u002Fdisplay toggling, using a library such as [validate.js](https:\u002F\u002Fvalidatejs.org\u002F).\n\n## Design principles\n\n- JavaScript is a pre-requisite, so beyond showing a nice message don't worry about progressive enhancement.\n- We can share code front and backend (if that makes sense) but we must write it only once\n- All code must be testable\n- The application must be responsive with no significant latency\n- \n\n## Solution design\n\nEasiest to think about this in terms of interface boundaries\n\n| JavaScript        | WASM Frontend | Backend        | Notes                                    |\n| ----------------- | ------------- | -------------- | ---------------------------------------- |\n| onLoad setup      | setupForm     | getQuestionSet | grab data from backend to generate form  |\n| onChange validate | -             | -              | perform simple validation in front end   |\n| onChange update   | updateX       | -              | update central WASM model as they change |\n| onSubmit validate | validateX     | -              | perform complex multifield validation    |\n| onSubmit submit   | submitX       | submitX        | ensure validated, pass to backend        |\n\n### QuestionSet data structure\n\nThere should be sufficient information in here for both display and simple validation.\n\n```JSON\n{\n    \"question-set\": \"string\", \u002F\u002F questionset identifier, there may be many in a single journey\n    \"questions\": [\n        {\n            \"type\": \"string\", \u002F\u002F text | number | datetime | select | radio | ...\n            \"name\": \"string\", \u002F\u002F form control name\n            \"label\": \"string\", \u002F\u002F form control label\n            \"default\": \"string\", \u002F\u002F maps to (value | checked) property\n            \"helptext\": \"string\", \u002F\u002F markdown tooltip or subtext, depending on cosmetic choices\n            \"valid-required\": \"boolean\", \u002F\u002F maps to required property\n            \"valid-max\": \"integer\", \u002F\u002F maps to (max | maxLength) property\n            \"valid-min\": \"integer\", \u002F\u002F maps to (min | minLength) property\n            \"valid-regexp\": \"string\", \u002F\u002F maps to pattern property\n            \"valid-errmsg\": \"string\", \u002F\u002F error message to go with regexp validation\n            \"data-source\": \"string\", \u002F\u002F data-source attribute used for reference data\n            \"pre-markdown\": \"string\", \u002F\u002F markdown to render before the question\n            \"post-markdown\": \"string\", \u002F\u002F markdown to render after the question\n            \"display-if-parent\": \"string\", \u002F\u002F data-parent attribute - hide until parent condition met\n            \"display-if-value\": \"string\" \u002F\u002F data-parent-val attribute\n        },\n        \u002F\u002F ...\n    ]\n}\n```\n### Validate & submit\n\n- Should have already performed simple validation in the browser\n- Should already have all required values from the questionset submitted during navigation\n- Assume neither of these things are true, validate in full.  \n  This can mean running validation twice, but the client side stuff was for the user's benefit and we didn't write it by hand for this journey, the underlying data which drives it was generated in the backend.\n\n1. All fields in questionset answered, click submit button.\n2. JavaScript onSubmit() code calls WebAssembly ProcessQuestionSet() which returns error string or \"\".\n3. JavaScript either displays errors or navigates onwards (can preload next page while waiting for response)\n4. Wasm applies business logic and passes data on for further processing if required\n\n- Page URLs and navigation are the domain of the JS.\n- Data, session and persistence are the domain of the backend & wasm frontend\nThese 2 aspects aren't entirely independent...\n\nIf we choose to go down the SPA route then we can consider the WASM memory as the session data.  \nWe also have the option here to break up the questionSet into as many or as few chunks as we like.\nWe can even combine questionSets within the same business logic, since all exist in session data together.\n\nIf we choose to go down the multipage route then we need to call out to a persistence layer in between pages.\nThis persistence layer could be in the browser (localStorage\u002FsessionStorage) or backend via an async API call, either way this should be handled by WASM.\nAny time we need to look at data spanning questionSets (pages in this scenario) we need to also perform data retrieval steps to pull in data from other pages, this starts to feel messy so SPA seems preferable all things considered.\n\n### Conclusion\n\n- Layer separation is clear and there is no code duplication.\n- Browser-based data-annotation-driven validation is proven and well known\n- The practicalities of interop for questionSet submission to be proven, can't add too much latency.\n- WASM to backend APIs via REST or gRPC to be considered - not clear on security in WASM \n\n\n\n"}</script></div>
	</body>
</html>
