<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="/favicon.ico" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />

		<meta http-equiv="content-security-policy" content="">
	<link rel="stylesheet" href="/_app/assets/pages/__layout.svelte-711b4112.css">
	<link rel="modulepreload" href="/_app/start-7208c571.js">
	<link rel="modulepreload" href="/_app/chunks/vendor-5ca848cc.js">
	<link rel="modulepreload" href="/_app/pages/__layout.svelte-8da8bfc2.js">
	<link rel="modulepreload" href="/_app/pages/blog/_slug_.svelte-db98abb9.js">
	</head>
	<body>
		<div>



<div class="svelte-1lrvsco"><header><h1 class="svelte-1lrvsco">Mark Temple-Heald</h1>
  <h2 class="svelte-1lrvsco">the right tool for the job</h2></header>

<nav class="svelte-r02kv1"><ul class="svelte-r02kv1"><li class="svelte-r02kv1"><a href="/" class="navAnchor">Home</a></li>
    <li class="svelte-r02kv1"><a href="/blog" class="navAnchor">Blog</a></li>
    <li class="svelte-r02kv1"><a href="/topic" class="navAnchor">Topic</a></li>
    <li class="svelte-r02kv1"><a href="/about" class="navAnchor">About</a></li></ul>
</nav>
</div>

<main class="svelte-lv7236"><!-- HTML_TAG_START --><h1>Building a Serverless Application in Azure</h1>Serverless computing is getting a lot of attention at the moment, touted as a great way to get to market quickly and popular with startups.<br />My aim with this project is to add this tool to my arsenal by building a small but realistically complex proof of concept application:<ul><li>Backend built using Azure Functions written in C# and .NET Core</li><li>Frontend hosted in Azure Static Content Hosting using AngularJS to connect to the backend service</li></ul><br />Key principles:<ul><li>Separate application logic and integration details to facilite unit testing, portability and supportability.<br />Continuous deployment (CD) where every check-in to the master branch results in a production release.</li><li>Open source, because why not?  Maybe it is interesting to someone, or perhaps I can learn something from others who see it.</li><li>Try to be cloud agnostic, realistically this is only partially possible at present but let's see where we get up to.<br />Establish clear cost management, arguably the most important factor regarding practicality.<br />Minimum Viable Product (MVP) - A working application with no data persistence and limited security.</li></ul><h3><a href="https://mthcricket01ui.z16.web.core.windows.net/">Live application</a>.  </h3><h2>Application Logic</h2>Cricket is a darts game played by 2 or more people.<br />The idea is to tick off 3 of each of the numbers 15-20 plus the bull (centre bull counts double).<br />Hitting a number which you've already completed but others haven't scores you those points.<br />The winner is the first to complete this checklist and also have the best score overall.<br />| Player   | Bull | 20  | 19  | 18  | 17  | 16  | 15  | Points | Ranking |
| -------- | ---- | --- | --- | --- | --- | --- | --- | ------ | ------- |
| Player 1 | XXX  | XXX | XXX | XXX | XXX | XXX | XXX | 0      | 1       |
| Player 2 | XXX  | XXX | XXX | XXX | XXX | XXX | XXX | 100    | 2       | <br />There are additional extended rules too, notably:<ul><li>Cutthroat - scores go on everybody else, not you, the winner has the lowest score at the end</li><li>Require 3 - If all 3 hits on a number aren't completed within a single visit they aren't saved for the next visit</li><li>Unlimited vs round-based, usually 20 rounds</li></ul><h2>Development process</h2><ol><li>Set up version control.  </li></ol><pre class="code poetry"><code>I've opted to use a GitHub-hosted [Git repository](https://github.com/mtempleheald/cricket-azure).</code></pre><ol><li>Set up a development environment.  </li></ol><pre class="code poetry"><code>I've chosen VS Code on Windows with extensions C#, .NET Core Test Explorer, Azure Functions.  
I'm working alone, there's no need for collaboration tools for this project, documentation to be housed with the code.</code></pre><ol><li>Write the domain logic (C#, .NET Standard), ignorant of hosting considerations.  </li></ol><pre class="code poetry"><code>Testing (xUnit) with a pragmatic TDD approach, that is I'm not writing code just to pass tests, but I am writing tests first.  </code></pre><ol><li>Configure build pipeline, triggered from check-in to master.  </li></ol><pre class="code poetry"><code>Azure DevOps uses [azure-pipelines.yml](https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=vsts&tabs=schema).  
I'm a little uncomfortable now in terms of vendor lock-in, but at least I'm building CI in from the start, defined in the codebase, can switch later.  </code></pre><ol><li>Build the function wrappers (API) referencing the tested domain project (with tests) and add to build pipeline.  </li></ol><pre class="code poetry"><code>Now I'm learning.  It is immediately clear that this code can never be portable to AWS, GCP etc, wrappers would instead need to be built separately.</code></pre><ol><li>Configure release pipeline, triggered from successful build/test.  </li></ol><pre class="code poetry"><code>Azure DevOps this is currently UI-driven, YAML expected [2018 Q4](https://dev.azure.com/mseng/Azure%20DevOps%20Roadmap/_workitems/edit/1221170).  
Again, this is worryingly Azure-specific but it has to be to some extent, we're now connecting to the platform itself.  </code></pre><ol><li>Build independent integration tests, this is on hold but will probably use Postman on the command line (Newman).<br />Build the user interface and add to build/ release pipelines.  </li></ol><pre class="code poetry"><code>I stick with consistent naming convention for collation purposes but this is an AngularJS (for now) project, not .NET.</code></pre><ol><li>Manual live smoke testing.  </li></ol><h2>Code structure and naming</h2>Projects:<ul><li>Mth.Darts.Cricket</li></ul><pre class="code poetry"><code>* Domain service (business logic), C#, .NET Standard
* Minimise dependencies to maximise portability, reduce build times and improve supportability.  </code></pre><ul><li>Mth.Darts.Cricket.Tests</li></ul><pre class="code poetry"><code>* Business logic tests, C#, xUnit </code></pre><ul><li>Mth.Darts.Cricket.Api</li></ul><pre class="code poetry"><code>* Application service (Azure functions) referencing the domain service, C#, .NET Core</code></pre><ul><li>Mth.Darts.Cricket.Api.Tests</li></ul><pre class="code poetry"><code>* Application service tests, C#, xUnit</code></pre><ul><li>Mth.Darts.Cricket.Ui</li></ul><pre class="code poetry"><code>* User interface, static web pages using AngularJS to reference the Api</code></pre><h2>Standards</h2><ul><li>1 file per class/ struct, even if only used in one place</li><li>Files names in a collation-friendly way, nested items to be prefixed with the parent name</li><li>Comments where they add value, must describe the why not the how (that should be obvious from the code)</li><li>Hold scoreboard state in nested structs not classes because <a href="https://softwareengineering.stackexchange.com/questions/92339/when-do-you-use-a-struct-instead-of-a-class">has no identity, defined by its data</a></li><li>JSON Serialisation using Newtonsoft.Json - <a href="https://stackoverflow.com/questions/32008869/json-net-serialize-specific-private-field">use attributes to expose private properties</a></li><li>Adopt REST API standards, e.g. avoid verbs, pluralise collections always</li><li>single .gitignore file at root as usually recommended</li><li>.vscode settings checked-in could help future developers, no harm to the code to keep them</li></ul><h2>API</h2>The connection between front and backend is through a REST API (Azure Function App) with 4 key endpoints (Functions):<ul><li>create match</li></ul><pre class="code poetry"><code>* requires list of players and match settings
* returns new match, initialised with zero scores/ hits
* POST: /api/matches</code></pre><ul><li>throw dart</li></ul><pre class="code poetry"><code>* requires current match state and details of the current throw
* returns updated match
* POST: /api/matches/123/</code></pre><ul><li>undo throw</li></ul><pre class="code poetry"><code>* requires current match state (including history of throws)
* returns updated match state
* POST: /api/matches/123/undo</code></pre><ul><li>start new game</li></ul><pre class="code poetry"><code>* requires current match state (with current game marked as complete)
* returns updated match state
* POST: /api/matches/123/newgame</code></pre>These are all independently deterministic but obviously need to be combined in a logical order to manage the flow of a Cricket darts match.<br />This activity will be left to the caller to manage for the MVP, with persistent this may change.<br /><h2>Azure Functions</h2>A key component of this serverless design is the use of scalable functions, for which I've chosen Azure Functions.<br />Azure deploys functions within an umbrella entity called a <strong>Function App</strong>.<br />Function Apps are considered infrastructure and the recommended deployment approach is to use <a href="https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-authoring-templates">Azure Resource Manager (ARM) templates</a>.<br />Functions are considered code and the recommended deployment approach is to use <a href="https://docs.microsoft.com/en-gb/azure/azure-functions/deployment-zip-push">Zip Deployment</a>.<br /><h2>Create Function App manually</h2>In the interest of understanding before coding I experimented by manually creating a Function App using QuickStart (Azure Portal).<br /><ul><li>resource group:             xmthcricket01</li><li>function app:               xmthcricket01functionapp</li><li>storage account (required): xmthcricket01storageaccount</li></ul><br />I feel that standards are important from the start so I settled on naming convention %owner%%application%%version%%resource%.<br />I avoided underscores, hyphens, mixed case because storage accounts don't allow them and consistency trumps appearance in my opinion.<br />I then examined the storage account, since I didn't understand its purpose.<br /><ul><li>Blob container <em>azure-webjobs-hosts</em> used for storing blob receipts, ensuring that each blob is only processed once.</li><li>Blob container <em>azure-webjobs-secrets</em> used for storing keys/secrets required by the function app (I guess, can't find documentation).</li><li>File share xmthcricket01 which guessing from the name represents the function app</li></ul><pre class="code poetry"><code>* .nuget        (capture NuGet dependencies)
* .ssh          (for connectivity)
* data          (ASP.NET compilation snapshots, function secrets + sample data)
* LogFiles      (for if we opt to inject logging into our functions)
* site
    * deployments   (deployment settings + history - will need to be tidied up at some point)
    * diagnostics   (diagnostics settings)
    * locks         (empty)
    * repository    (source code depending on deployment approach)
    * wwwroot       (The published function app itself)</code></pre>Makes sense, everything needed to make the app run is stored in a storage account we own, though don't need to actively manage (serverless).<br />I'm not going to worry too much about the details except that:<br /><ul><li>For automation purposes we need to replace the wwwroot directory contents</li><li>Deployment history could build up and storage accounts are paid for by size, so cleanup may be required  </li></ul><h2>Create Function App with code</h2>The most familiar way for me to create a C# HTTP trigger based function is the <a href="https://github.com/dotnet/cli">dotnet CLI</a>:<br />``<code> dotnet new func </code>`` to create the project from within a target folder<br />``<code> dotnet new http </code>`` to create a new http trigger function within a function app project<br />Producing the structure seen in the <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-dotnet-class-library">Azure functions C# Developer reference</a>.<br />It is also possible using the <a href="https://github.com/Azure/azure-functions-core-tools">azure-functions-core-tools</a>:<br />``<code> func init </code>`` to create a function app, selecting a runtime (dotnet, selected from list)<br />``<code> func new </code>`` to create a function, C# httpTrigger<br />The end result is very similar:<br /><ul><li>.csproj with netcoreapp2.1 set as the target framework<br />host.json with version set to "2.0"<br />local.settings.json  </li></ul><br /><pre class="code "><code>{
    &quot;IsEncrypted&quot;: false,
    &quot;Values&quot;: {
        &quot;AzureWebJobsStorage&quot;: &quot;&quot;,
        &quot;FUNCTIONS_WORKER_RUNTIME&quot;: &quot;dotnet&quot;
    }
}</code></pre><br /><ul><li>A hello world sample function; Company.Function.http  </li></ul><br /><pre class="code "><code>...
using Microsoft.Azure.WebJobs.Extensions.Http;
using Microsoft.Extensions.Logging;
namespace Company.Function
{
    public static class http
    {
        [FunctionName(&quot;http&quot;)]
        public static async Task&lt;IActionResult&gt; Run(
            [HttpTrigger(AuthorizationLevel.Function, &quot;get&quot;, &quot;post&quot;, Route = null)] HttpRequest req,
            ILogger log)
        {
            ...
            string name = req.Query[&quot;name&quot;];
            ...            
            return name != null
                ? (ActionResult)new OkObjectResult($&quot;Hello, {name}&quot;)
                : new BadRequestObjectResult(&quot;Please pass a name on the query string or in the request body&quot;);
        }
    }
}</code></pre>
Simple enough, an asynchronous JSON REST endpoint which accepts GET and POST methods, expects a / route, does some basic validation and returns a response.<br />This is .NET Core so no surprises that logging is available by dependency injection.<br />This example has everything I need for now so no need to dwell on the details.<br />Time to build my own...<br /><a href="https://github.com/mtempleheald/cricket-azure/blob/master/Mth.Darts.Cricket.Api/StartMatch.cs">Mth.Darts.Cricket.Api.StartMatch</a> should:<ul><li>accept POST only</li><li>expect a route of /api/matches</li><li>expect parameters of scoring<em>mode, max</em>rounds and a list of \[player\[</a></a>, or a single json object containing all three</li><li>reference the domain service, specifically the Match constructor to get back a Match object, tested elsewhere</li><li>return a json object representing the Cricket match if all went well, an error message otherwise</li></ul><h2>Testing Azure functions</h2>There are several different facets to testing here:<ol><li>Logic - nothing to do with serverless design but the most important part in my opinion</li><li>Plumbing - does the function work as expected when called directly using an HttpRequest object?</li><li>Routing - does an HTTP request get picked up by the expected function?</li><li>Integration - When deployed does everything just work?</li></ol><h3>Testing logic</h3>Nothing new here, create a test project using ``<code> dotnet new xunit </code>``<br />I did make things awkward for myself by restricting access on as much as possible so had to tweak the project to <a href="https://stackoverflow.com/questions/15440935/how-to-test-internal-class-library#answer-15440997">make internals visible to the test project</a>.<br /><h3>Testing function plumbing</h3>No need to repeat anything here, I followed the guide to <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-test-a-function">testing azure functions</a>, extended it for multiple parameters and a different return value and used a JSON test file.<br /><h3>Testing function routing</h3>In REST terms a match can be considered a <em>resource</em>, a member of the matches <em>collection</em>.<br />To create a match we need to pass parameters to the uri, repeating the player parameter as many times as required.<br />For a 2 player match between Van Gerwen and Taylor we need to<br />``<code>POST /api/v1/matches/?scoring_mode=Standard&max_rounds=0&player[]=Van%20Gerwen&player[]=Taylor</code>``<br />Initially there's no persistent data store, so this match isn't retrievable, but if it were it would be available at, e.g. /api/v1/matches/123.<br />Note that I converted player to player\[</a> in the url, because this is what AngularJS and some backend frameworks consider correct, though I can't find a definitive answer on the matter anywhere.<br />To run Azure Functions locally from within the function app project use the Azure Functions Core Tools: ``<code> func start </code>``<br />I've opted to manually test routing using Postman for the MVP but intend to automate this eventually, using one of:<ul><li>Postman CLI tool <a href="https://learning.getpostman.com/docs/postman/collection_runs/command_line_integration_with_newman/">Newman</a></li><li>.Net Core <a href="https://docs.microsoft.com/en-us/aspnet/core/test/integration-tests?view=aspnetcore-2.2">Integration tests</a></li></ul><h2>Continuous Integration, Delivery & Deployment</h2>In modern software development there is no excuse to not have some form of continuous integration (CI).<br />Build and Test automation is usually easy and cheap to setup and pays for itself even in the short term.<br />It is also entirely within the control of the software development team.<br />How you implement this is dependent on the team and project requirements, for this project I'm just building on the master branch.<br />Continuous delivery is just as valuable, all projects should strive for some degree of this, but it is significantly harder to implement.<br />Release automation complexity depends on the technology stack and collaboration with TechOps but the benefits far outweigh the costs.<br />Continuous deployment takes this a step further, automating releases without human intervention, subject to quality gates from automated testing.<br />This is a cultural thing, not all organisations or teams can work in this way for a myriad of reasons.<br />I can though, for this project, so that's the plan, straight to production after every build which passes tests.<br /><h2>Build pipeline</h2>Two mandatory requirements here:<ul><li>Build automatically triggered every time the code is changed.</li><li>Build steps live with the code because who better to know how to build an application than the application developer?</li></ul>
And one optional requirement:<ul><li>Build should be target-agnostic for portability, to avoid vendor lock-in</li></ul><br />Focussing just on the mandatory requirements for the MVP I followed Microsoft's advice on <a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/repos/github?view=vsts">Linking Azure DevOps to GitHub</a>.<br />I chose the <strong>GitHub App</strong> option because I didn't want it linked directly to my credentials.
In GitHub <strong>Azure Pipelines</strong> now shows up under <em>Settings > Integration & services > Installed GitHub Apps</em> where I can configure it to restrict access to specific repositories or remove it altogether.<br />In Azure DevOps <strong>mtempleheald</strong> now shows up under <em>Project Settings > Pipelines > Service Connections</em>, I can disconnect it here but it tells me that any configuration must be done on GitHub.<br />During this process a default <a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/process/tasks">azure-pipelines.yml</a> file was presented to me with the option to commit it, which I accepted.  From here it didn't take long to configure a working build by chaining dotnet CLI commands together.<br />It is very easy to break a build so having this set up early on is really important for stability, I'd say that this is step 1 on the way to true DevOps, where the developers take responsibility for handover of artifacts.<br />Some nice visual feedback and convenient logging, plus a status badge is available for the project 
<a href="https://dev.azure.com/mtempleheald/cricket-azure/_build/latest?definitionId=1?branchName=master"><img src="https://dev.azure.com/mtempleheald/cricket-azure/_apis/build/status/mtempleheald.cricket-azure?branchName=master" alt="Build Status"></a><h3>Build steps</h3>Build steps used:<ul><li>script: ``<code> dotnet --version </code>`` - check that we know which version of .NET lives on the Microsoft-managed build agent</li><li>script: ``<code> dotnet build '&lt;project&gt;' --configuration $(buildConfiguration) </code>`` - build a named project</li><li>task: ``<code> DotNetCoreCLI@2 </code>`` - run tests</li><li>script: ``<code> dotnet publish '&lt;function_app_project&gt;' --output '&lt;target_dir&gt;' </code>`` - prepare function app artifacts for publication</li><li>task: ``<code> CopyFiles@2 </code>`` - copy specified files to artifact drop location</li><li>task: ``<code> PublishBuildArtifacts@1 </code>`` - publish the artifacts ready for the release pipeline</li></ul><br />output of dotnet publish:<ul><li>FunctionApp</li></ul><pre class="code poetry"><code>* bin/
* StartMatch
    * function.json
* host.json
* *.deps.json</code></pre>which seems to match the <a href="https://docs.microsoft.com/en-gb/azure/azure-functions/functions-continuous-deployment#continuous-deployment-requirements">continuous deployment requirements</a>.<br />What this doesn't make clear however is that the top level folder is not expected within the zip file.<br />This is important as it means that the build pipeline does not need to provide the name for the deployed artifact and facilitates a multi-environment deployment from a single build artifact (assuming everything else is parameterised appropriately).<br /><h2>Azure DevOps Artifacts</h2>It is good practice to keep build and release steps separate <a href="https://12factor.net/build-release-run">The 12 Factor App</a>.<br />This makes sense, there may be some overlap but build steps are developer controlled and release steps are about environment config and is more of a TechOps role unless you truly embrace DevOps.<br />In the terminology of Azure DevOps I need to publish an <strong>artifact</strong> on the <strong>build pipeline</strong> to make it available to the <strong>release pipeline</strong>.<br />This is simple, but very easy to make mistakes, so it is useful to be able to debug pipeline execution.<br />It helps to understand how files are stored on the build/release agents, <a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/build/variables?view=vsts">pre-defined variables</a><br />| Path structure    | System.                                    | Build.                                    | Agent.                   |
| ----------------- | ------------------------------------------ | ----------------------------------------- | ------------------------ |
| /agent/           |                                            |                                           | HomeDirectory            |
| /agent/work/      | WorkFolder                                 |                                           | RootDirectory WorkFolder |
| /agent/work/1     |                                            |                                           | BuildDirectory           |
| /agent/work/1/s   | DefaultWorkingDirectory                    | SourcesDirectory                          |                          |
| /agent/work/1/b   |                                            | BinariesDirectory                         |                          |
| /agent/work/1/a   |                                            | ArtifactStagingDirectory StagingDirectory |                          |
| /agent/work/r1/a  | ArtifactsDirectory DefaultWorkingDirectory |                                           | ReleaseDirectory         |<br />Most of these steps provide useful information but if it isn't enough we can add extra debug information:<br /><ul><li>To debug build steps add ``<code> system.debug: true </code>`` to azure-pipelines.yml.<br />To debug release steps add <em>system.debug</em> to the Variables tab on the UI, with a value of true.  </li></ul><br />A notable issue I had was with the release pipeline being unable to find the published function app artifact, despite triple-checking paths and successful step execution:<ul><li>Zip up function app - <em>Successfully created archive: /home/vsts/work/1/a/11.zip</em></li><li>Publish Build Artifacts - no listed output (suspicious but successful)</li></ul><br />It turns out that the publish step was failing silently because I'd put an incorrect parameter in.  I only figured this out by looking at the <a href="https://github.com/Microsoft/azure-pipelines-tasks/blob/master/Tasks/PublishBuildArtifactsV1/publishbuildartifacts.ts">source code</a> of the suspicious step.  There are 2 allowed values for artifactType; 'Container' and 'FilePath'.  Turns out I'd been passing the description of container instead ('Azure Pipelines/TFS') - oops!<br /><ul><li>Publish Build Artifacts - <em>Upload '/home/vsts/work/1/a' to file container: '#/2495698/drop'</em> - success!</li></ul><h2>Release pipeline</h2>Azure DevOps release pipelines currently work differently from build pipelines, although release pipeline Configuration as code (YAML) is <a href="https://dev.azure.com/mseng/Azure%20DevOps%20Roadmap/_workitems/edit/1221170">planned for 2018 Q4</a>.<br />That being said, tasks are common but categorised (build, utility, test, package, deploy, tool) - <a href="https://github.com/Microsoft/azure-pipelines-tasks/tree/master/Tasks">code</a>.<br />So there is nothing stopping me from adding release steps to the azure-pipelines.yml file above, but I'm going to do it properly instead, keeping build and release separate by using the published artifacts.<br /><h3>Connecting the release pipeline to Azure</h3>The Azure Portal function app page has a <em>Deployment Center</em> tab, where you can configure a Git repository connection.<br />This uses <a href="https://github.com/projectkudu/kudu">Kudo</a> which by default expects either 1 solution or 1 project to deploy, but can be <a href="https://github.com/projectkudu/kudu/wiki/Customizing-deployments">customised</a>. <br />It can also be customised in the Azure portal, by adding the target project (<em>PROJECT = function-app/function-app.csproj</em>)<br />to application settings <em>Azure > Overview > Application Settings > Application Settings</em>
I'm uncomfortable with this approach for several reasons:<ul><li>The GitHub connection is tied directly to my account</li><li>This configuration is hidden away and easily forgotten, though I could address this using the custom .deployment file in the code.<br />What about the other elements of the release?  Storage, static content, I want consistency in my releases.</li></ul><br />The better approach is to manage releases within an independent release pipeline (Azure DevOps), even when aiming for continuous deployment.<br />This requires setting up an Azure Resource Manager (ARM) connection:<br /><em>Azure DevOps > Project Settings > Pipelines > Service Connections > New Service Connection > Azure Resource Manager</em><br />For which I had to <a href="https://docs.microsoft.com/en-gb/azure/active-directory/develop/howto-create-service-principal-portal">create a service principal</a>:<br /><ol><li>Azure Portal > App Registrations > Create > Web App (url not important yet)</li><li>Azure Portal > Subscriptions > ~MySubscription~ > IAM > Add role assignment > Contributor + App name</li></ol><br />I could now access the parameters required to add the connection:<br /><ul><li>Tenant-Id:  </li></ul>
  Azure Portal > Azure Active Directory > Properties > Directory ID<ul><li>Application ID:  </li></ul>
  Azure Portal > App Registrations > ~My App~ > Application ID<ul><li>Authentication Key:  </li></ul>
  Azure Portal > App Registrations > ~My App~ > Settings > Keys<br />Hereafter release pipeline tasks simply need to refer to this connection and it just works.<h3>Release pipeline steps </h3><ul><li><a href="https://github.com/Microsoft/azure-pipelines-tasks/blob/master/Tasks/AzureResourceGroupDeploymentV2/README.md">ARM deployment</a> - all infrastructure elements within the resource group, the equivalent of using the command line tools:  </li></ul>
<pre class="code "><code>$resourceGroup = 'mthtest01'
$storageAccount = &quot;$($resourceGroup)apistorage&quot;
$appServiceplan = &quot;$($resourceGroup)plan&quot;
$functionApp = &quot;$($resourceGroup)api&quot;
az group create --name $resourceGroup --location westeurope
az storage account create --name $storageAccount --location westeurope --resource-group $resourceGroup --sku Standard_LRS
az appservice plan create --name $appServiceplan --resource-group $resourceGroup --sku B1 --is-linux
az functionapp create --resource-group $resourceGroup --plan $appServiceplan --name $functionApp --storage-account $storageAccount --runtime dotnet</code></pre><ul><li><a href="https://aka.ms/azurermwebdeployreadme">Azure App Service Deploy (Preview)</a> - azure function deployment to function app</li><li><a href="https://aka.ms/azurefilecopyreadme">Azure File Copy (Preview)</a> - static website copied to $web blob container</li><li><a href="https://github.com/Microsoft/azure-pipelines-tasks/blob/master/Tasks/AzureCLIV1/Readme.md">Azure CLI</a> - using the az command line tools to turn the blob container into a static website:  </li></ul>
<pre class="code "><code>az extension add --name storage-preview --debug
az storage blob service-properties update --account-name &quot;$(resourceGroup)ui&quot; --static-website --404-document 404.html --index-document index.html --debug</code></pre><h2>ARM templates for continuous deployment</h2>I have come across ARM templates before and know that they're the recommended approach for (re)deploying Azure artifacts in a consistent fashion, but I've never built any from scratch, so it is time to investigate.  My aim here is to develop a pattern which I can use again for another serverless app in Azure, without having to think about this stuff again.  This has been easily the most time-consuming part of this project.<br />I want a single ARM template containing all aspects of the serverless application MVP:<ul><li>Storage account for static file hosting</li><li>Storage account for function app support</li><li>Function app (It is possible but makes little sense to <a href="https://blog.kloud.com.au/2018/08/16/deploying-azure-functions-with-arm-templates/">deploy functions themselves using ARM</a>)</li></ul><br />ARM <a href="https://docs.microsoft.com/en-gb/azure/azure-resource-manager/resource-group-authoring-templates">template structure</a>:<ul><li>parameters    - passed on execution, e.g. environment/ version/ build number</li><li>variables     - build upon parameters and group names together for consistency</li><li>functions     - user-defined functions</li><li>resources     - deploy stuff - <a href="https://docs.microsoft.com/en-gb/azure/azure-resource-manager/resource-manager-templates-resources">intro</a></li><li>outputs       - capture values from during execution in case further processing required, e.g. url available</li></ul><br />There are some useful <a href="https://github.com/Azure/azure-quickstart-templates">quickStart templates</a> to learn from, specifically <a href="https://raw.githubusercontent.com/Azure/azure-quickstart-templates/master/101-storage-account-create/azuredeploy.json">101-storage-account-create</a> and <a href="https://github.com/Azure/azure-quickstart-templates/blob/master/101-function-app-create-dynamic/azuredeploy.json">101-function-app-create-dynamic</a>.<br />It can also be useful to create stuff manually once and view the generated script:<br />Azure Portal > Resource Groups > %Resource Group% > Automation Script<br />I also found it useful to briefly look at the REST APIs which ARM deployment use under the hood:<br /><ul><li><a href="https://docs.microsoft.com/en-us/rest/api/storagerp/storageaccounts">storage account REST API</a><br /><a href="https://docs.microsoft.com/en-us/rest/api/appservice/webapps">webapps REST API</a>  </li></ul><h3>Preparing the ARM template</h3>Starting with naming I want the following visible in the Azure Portal:<ul><li>mthcricket01 (resource group)</li><li>mthcricket01api (function app)</li><li>mthcricket01apistorage (storage account required by function app)</li><li>mthcricket01ui (storage account for static content)</li></ul><br />This is easily achieved using variables:<br /><pre class="code json"><code class="language-json">&quot;variables&quot;: {
        &quot;functionApp&quot;: &quot;[concat(resourceGroup().name, 'api')]&quot;,
        &quot;functionAppStorage&quot;: &quot;[concat(resourceGroup().name, 'apistorage')]&quot;,
        &quot;uiStorage&quot;: &quot;[concat(resourceGroup().name, 'ui')]&quot;
    }</code></pre><br />The real details are in the resources section and this can get quite complicated; you have to learn Azure terminology, relationships and specify API versions.<br />I've found the most useful information in the <a href="https://docs.microsoft.com/en-us/azure/templates">Azure template reference</a> where apiVersion options are clear.<br />This is also available through Azure PowerShell:<br /><pre class="code "><code>(Get-AzResourceProvider -ProviderNamespace Microsoft.Storage).ResourceTypes | Where {$_.ResourceTypeName -eq 'storageAccounts'} | select -ExpandProperty ApiVersions
2018-07-01
2018-03-01-preview
...
2015-05-01-preview
(Get-AzResourceProvider -ProviderNamespace Microsoft.Web).ResourceTypes | Where {$_.ResourceTypeName -eq 'sites'} | select -ExpandProperty ApiVersions
(Get-AzResourceProvider -ProviderNamespace Microsoft.Web).ResourceTypes | Where {$_.ResourceTypeName -eq 'serverfarms'} | select -ExpandProperty ApiVersions
(Get-AzResourceProvider -ProviderNamespace Microsoft.Web).ResourceTypes | Where {$_.ResourceTypeName -eq 'functions'} | select -ExpandProperty ApiVersions
2018-11-01
2018-02-01
...
2014-04-01</code></pre><br />It took me a long time to get to grips with apiVersion, in the end I realised that it was the tooling in VS Code that was causing the confusion with unnecessary warnings, I learnt to instead just perform a test run in PowerShell (requires the <a href="https://docs.microsoft.com/en-gb/powershell/azure/install-az-ps?view=azps-1.0.0&viewFallbackFrom=azurermps-4.0.0">Azure PowerShell module</a>):<br /><pre class="code "><code>Connect-AzAccount
Select-AzSubscription -SubscriptionName 'Free Trial'
New-AzResourceGroup -Name $resourceGroupName -Location 'North Europe'
Test-AzResourceGroupDeployment -ResourceGroupName $resourceGroupName -TemplateFile .\azuredeploy.json -Debug</code></pre><br />It is possible to have the template refer to the latest version, using ``<code> [providers('&lt;provider&gt;','&lt;type&gt;').apiVersions[0]] </code>`` but this opens you up to breaking changes, so I'm avoiding that route.  I do think that it is important to be on the latest version you can be, this is a process thing, add the upgrade step into any future template update tasks.<br />Once I was comfortable that I knew which versions I was aiming for I was able to get it done:<br /><ul><li><a href="https://docs.microsoft.com/en-us/azure/templates/microsoft.web/2018-02-01/sites">Function App</a></li><li><a href="https://docs.microsoft.com/en-us/azure/templates/microsoft.web/2018-02-01/serverfarms">Hosting Plan for function app</a></li><li><a href="https://docs.microsoft.com/en-us/azure/templates/microsoft.storage/2018-07-01/storageaccounts">Storage Account</a></li></ul><br />Another awkward bit is configuring the <a href="https://docs.microsoft.com/en-gb/azure/azure-functions/functions-app-settings">App Settings for Azure Functions</a>.<br />properties > siteConfig > appSettings:<ul><li>AzureWebJobsStorage == <em>(DefaultEndpointsProtocol=https;AccountName=<a href="undefined">name</em></a>;AccountKey=<a href="undefined">key</a>)<em></li><li>AzureWebJobsDashboard == </em>(DefaultEndpointsProtocol=https;AccountName=<a href="undefined">name</a>;AccountKey=<a href="undefined">key</a>)<em></li><li>WEBSITE<em>CONTENTAZUREFILECONNECTIONSTRING == <em>(DefaultEndpointsProtocol=https;AccountName=<a href="undefined">name</em></em></em></a>;AccountKey=<a href="undefined">key</a>)<em></li><li>WEBSITE<em>CONTENTSHARE == <em>mthcricket01api</em></li><li>AzureWebJobsDisableHomepage == <em>true</em></li><li>FUNCTIONS</em>EXTENSION<em>VERSION == <em>~2</em></li><li>FUNCTIONS</em>WORKER<em>RUNTIME == <em>dotnet</em></li><li>AzureWebJobsDotNetReleaseCompilation == <em>false</em> (for debugging)</li><li>APPINSIGHTS</em>INSTRUMENTATIONKEY == </em>plan<em> </em></li></ul><br />I'm still working through the nuances of functionapp deployment, I'm getting internal server errors from Azure on the 2nd run through, having deployed fine the 1st run through.  The difficulty is primarily because this stuff is quite new and in flux, there are changes between <a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-versions">Runtime version 1 vs 2</a> plus I've chosen some awkward options like Linux hosting.<br />I opted part way through to adopt <a href="https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-linked-templates">Template Linking</a>.<br />This was simply because the template was already becoming uncomfortably long though I'm not sure this helped for my small project.<br />This didn't add too much complexity either, mostly moving the <em>DependsOn</em>  settings from the resource itself, to the deployment of the resource and providing template outputs.<br />I prefer this in principle because it is more modular.  For example the functionapp depends on the storage account connection string.  To get this you need to access the storage account API to get the key:<br />``<code> &quot;value&quot;: &quot;[listKeys(variables('StorageAccountName'), providers('Microsoft.Storage', 'storageAccounts').apiVersions[0])]&quot; </code>``<br />The equivalent in PowerShell: ``<code> (Get-AzStorageAccountKey -ResourceGroupName &lt;resource-group&gt; -Name &lt;storage-account&gt;).key1 </code>``<br />It feels right to me that this lives within the storage account creation template, not the function app, otherwise both templates need to manage apiVersions for the storage account API (although this example just uses latest).<h2>Costs</h2>This was never meant to be a serious production application, I'm certainly not expecting it to scale to fully utilise serverless scaling capabilities.<br />My intention was to use the <a href="https://azure.microsoft.com/en-gb/pricing/details/app-service/plans/">consumption plan</a>, therefore I was expecting it to be free or very close to.  <br />What I actually witnessed was that in the couple of weeks that I've had something running I accrued £0.09 on API storage and nearly £5 on an App Service Plan.  I've now addressed this, the ARM template was wrong, fixed by manually recreating all, viewing the generated Azure <em>automation script</em> and tweaking settings accordingly.<h2>Summary</h2>This project has been fairly successful so far, zero to <a href="https://mthcricket01ui.z16.web.core.windows.net/">Live application</a> in under a month.<br />I've also quite enjoyed bringing together lots of different elements I've used to varying degrees to build something real.<br />It isn't perfect of course, there are some known issues:<ul><li><s>Scores continue adding on even if all ticked off - API logic wrong</s> Fixed</li><li><s>Plan costing money, something isn't right about the functionapp deployment yet, consumption plan should be free (at low volumes).</s></li><li>Clicking too quickly misrepresents the status as evidenced by the history of throws - 2 choices (possibly both):</li></ul><pre class="code poetry"><code>* throttling within Angular controller, checksum-esque, possibly store actions in local queue before calling API (web worker?)
* incremement version within the API, check that requests are received in order, depends upon data persistence but may be better solution</code></pre><ul><li>Skip function totally broken (symptom of the above)</li><li>Initial load is extremely slow (several seconds) and it <em>appears</em> to be broken.  Possibly send a dummy request in the background to hide this from the user.</li><li>Buttons jump about a bit due to flexbox/ grid layout and conditional display of skip, would be nice to fix this</li></ul><br />There's also outstanding work to do:<br /><ul><li>Deployments building up in storage, no need to keep history of deployments so need to add clear step to release pipeline (start).</li><li>Better understand Azure's inner workings, or terminology at least, I feel that I'm missing something (or the documentation is).  Possibly I'm just more pedantic than most users, I want to understand it, not just get it working.</li></ul><!-- HTML_TAG_END --></main>


<footer class="svelte-14g1sgx"><p>This is my site, there are many like it but this one is mine.</p>
  <p>If you don&#39;t like it, you know where the close button is.</p>
  <a href="https://www.linkedin.com/in/mtempleheald" target="_blank" class="svelte-14g1sgx">Mark Temple-Heald</a>
  <a href="https://mtempleheald.github.io" target="_blank" class="svelte-14g1sgx">Home</a>
  <a href="https://github.com/mtempleheald" target="_blank" class="svelte-14g1sgx">GitHub</a>
  <p>Mindful meanderings manifest more manageable machinations.
    Manoeuvring murky multifaceted modernism means meticulously managing many mistakes, misconceptions, misunderstandings.
    Measured multipronged musings, mechanical movements, may maximise meritorious magnificence.
  </p>
</footer>


		<script type="module" data-hydrate="1nsuect">
		import { start } from "/_app/start-7208c571.js";
		start({
			target: document.querySelector('[data-hydrate="1nsuect"]').parentNode,
			paths: {"base":"","assets":""},
			session: {},
			route: true,
			spa: false,
			trailing_slash: "never",
			hydrate: {
				status: 200,
				error: null,
				nodes: [
					import("/_app/pages/__layout.svelte-8da8bfc2.js"),
						import("/_app/pages/blog/_slug_.svelte-db98abb9.js")
				],
				url: new URL("http://sveltekit-prerender/blog/2019-01-07-Serverless-Application-Azure-DevOps"),
				params: {slug:"2019-01-07-Serverless-Application-Azure-DevOps"}
			}
		});
	</script><script type="application/json" data-type="svelte-data" data-url="/api/blogs/2019-01-07-Serverless-Application-Azure-DevOps">{"status":200,"statusText":"","headers":{"content-type":"text/plain;charset=UTF-8"},"body":"# Building a Serverless Application in Azure\n\n\nServerless computing is getting a lot of attention at the moment, touted as a great way to get to market quickly and popular with startups.  \nMy aim with this project is to add this tool to my arsenal by building a small but realistically complex proof of concept application:\n* Backend built using Azure Functions written in C# and .NET Core\n* Frontend hosted in Azure Static Content Hosting using AngularJS to connect to the backend service\n\nKey principles:\n* Separate application logic and integration details to facilite unit testing, portability and supportability.  \n* Continuous deployment (CD) where every check-in to the master branch results in a production release.\n* Open source, because why not?  Maybe it is interesting to someone, or perhaps I can learn something from others who see it.\n* Try to be cloud agnostic, realistically this is only partially possible at present but let's see where we get up to.  \n* Establish clear cost management, arguably the most important factor regarding practicality.  \n* Minimum Viable Product (MVP) - A working application with no data persistence and limited security.\n\n### [Live application](https:\u002F\u002Fmthcricket01ui.z16.web.core.windows.net\u002F).  \n\n## Application Logic\n\nCricket is a darts game played by 2 or more people.  \nThe idea is to tick off 3 of each of the numbers 15-20 plus the bull (centre bull counts double).  \nHitting a number which you've already completed but others haven't scores you those points.  \nThe winner is the first to complete this checklist and also have the best score overall.  \n\n| Player   | Bull | 20  | 19  | 18  | 17  | 16  | 15  | Points | Ranking |\n| -------- | ---- | --- | --- | --- | --- | --- | --- | ------ | ------- |\n| Player 1 | XXX  | XXX | XXX | XXX | XXX | XXX | XXX | 0      | 1       |\n| Player 2 | XXX  | XXX | XXX | XXX | XXX | XXX | XXX | 100    | 2       | \n\nThere are additional extended rules too, notably:\n* Cutthroat - scores go on everybody else, not you, the winner has the lowest score at the end\n* Require 3 - If all 3 hits on a number aren't completed within a single visit they aren't saved for the next visit\n* Unlimited vs round-based, usually 20 rounds\n\n## Development process\n\n1. Set up version control.  \n   I've opted to use a GitHub-hosted [Git repository](https:\u002F\u002Fgithub.com\u002Fmtempleheald\u002Fcricket-azure).\n2. Set up a development environment.  \n   I've chosen VS Code on Windows with extensions C#, .NET Core Test Explorer, Azure Functions.  \n   I'm working alone, there's no need for collaboration tools for this project, documentation to be housed with the code.\n3. Write the domain logic (C#, .NET Standard), ignorant of hosting considerations.  \n   Testing (xUnit) with a pragmatic TDD approach, that is I'm not writing code just to pass tests, but I am writing tests first.  \n4. Configure build pipeline, triggered from check-in to master.  \n   Azure DevOps uses [azure-pipelines.yml](https:\u002F\u002Fdocs.microsoft.com\u002Fen-us\u002Fazure\u002Fdevops\u002Fpipelines\u002Fyaml-schema?view=vsts&tabs=schema).  \n   I'm a little uncomfortable now in terms of vendor lock-in, but at least I'm building CI in from the start, defined in the codebase, can switch later.  \n5. Build the function wrappers (API) referencing the tested domain project (with tests) and add to build pipeline.  \n   Now I'm learning.  It is immediately clear that this code can never be portable to AWS, GCP etc, wrappers would instead need to be built separately.\n6. Configure release pipeline, triggered from successful build\u002Ftest.  \n   Azure DevOps this is currently UI-driven, YAML expected [2018 Q4](https:\u002F\u002Fdev.azure.com\u002Fmseng\u002FAzure%20DevOps%20Roadmap\u002F_workitems\u002Fedit\u002F1221170).  \n   Again, this is worryingly Azure-specific but it has to be to some extent, we're now connecting to the platform itself.  \n7. Build independent integration tests, this is on hold but will probably use Postman on the command line (Newman).  \n8. Build the user interface and add to build\u002F release pipelines.  \n   I stick with consistent naming convention for collation purposes but this is an AngularJS (for now) project, not .NET.\n9. Manual live smoke testing.  \n\n## Code structure and naming\n\nProjects:\n* Mth.Darts.Cricket\n    * Domain service (business logic), C#, .NET Standard\n    * Minimise dependencies to maximise portability, reduce build times and improve supportability.  \n* Mth.Darts.Cricket.Tests\n    * Business logic tests, C#, xUnit \n* Mth.Darts.Cricket.Api\n    * Application service (Azure functions) referencing the domain service, C#, .NET Core\n* Mth.Darts.Cricket.Api.Tests\n    * Application service tests, C#, xUnit\n* Mth.Darts.Cricket.Ui\n    * User interface, static web pages using AngularJS to reference the Api\n\n## Standards\n\n* 1 file per class\u002F struct, even if only used in one place\n* Files names in a collation-friendly way, nested items to be prefixed with the parent name\n* Comments where they add value, must describe the why not the how (that should be obvious from the code)\n* Hold scoreboard state in nested structs not classes because [has no identity, defined by its data](https:\u002F\u002Fsoftwareengineering.stackexchange.com\u002Fquestions\u002F92339\u002Fwhen-do-you-use-a-struct-instead-of-a-class)\n* JSON Serialisation using Newtonsoft.Json - [use attributes to expose private properties](https:\u002F\u002Fstackoverflow.com\u002Fquestions\u002F32008869\u002Fjson-net-serialize-specific-private-field)\n* Adopt REST API standards, e.g. avoid verbs, pluralise collections always\n* single .gitignore file at root as usually recommended\n* .vscode settings checked-in could help future developers, no harm to the code to keep them\n\n## API\n\nThe connection between front and backend is through a REST API (Azure Function App) with 4 key endpoints (Functions):\n* create match\n    * requires list of players and match settings\n    * returns new match, initialised with zero scores\u002F hits\n    * POST: \u002Fapi\u002Fmatches\n* throw dart\n    * requires current match state and details of the current throw\n    * returns updated match\n    * POST: \u002Fapi\u002Fmatches\u002F123\u002F\n* undo throw\n    * requires current match state (including history of throws)\n    * returns updated match state\n    * POST: \u002Fapi\u002Fmatches\u002F123\u002Fundo\n* start new game\n    * requires current match state (with current game marked as complete)\n    * returns updated match state\n    * POST: \u002Fapi\u002Fmatches\u002F123\u002Fnewgame\n\nThese are all independently deterministic but obviously need to be combined in a logical order to manage the flow of a Cricket darts match.  \nThis activity will be left to the caller to manage for the MVP, with persistent this may change.  \n\n## Azure Functions\n\nA key component of this serverless design is the use of scalable functions, for which I've chosen Azure Functions.  \nAzure deploys functions within an umbrella entity called a **Function App**.  \nFunction Apps are considered infrastructure and the recommended deployment approach is to use [Azure Resource Manager (ARM) templates](https:\u002F\u002Fdocs.microsoft.com\u002Fen-us\u002Fazure\u002Fazure-resource-manager\u002Fresource-group-authoring-templates).  \nFunctions are considered code and the recommended deployment approach is to use [Zip Deployment](https:\u002F\u002Fdocs.microsoft.com\u002Fen-gb\u002Fazure\u002Fazure-functions\u002Fdeployment-zip-push).  \n\n## Create Function App manually\n\nIn the interest of understanding before coding I experimented by manually creating a Function App using QuickStart (Azure Portal).  \n* resource group:             xmthcricket01\n* function app:               xmthcricket01functionapp\n* storage account (required): xmthcricket01storageaccount\n\nI feel that standards are important from the start so I settled on naming convention %owner%%application%%version%%resource%.  \nI avoided underscores, hyphens, mixed case because storage accounts don't allow them and consistency trumps appearance in my opinion.  \nI then examined the storage account, since I didn't understand its purpose.\n\n* Blob container *azure-webjobs-hosts* used for storing blob receipts, ensuring that each blob is only processed once.\n* Blob container *azure-webjobs-secrets* used for storing keys\u002Fsecrets required by the function app (I guess, can't find documentation).\n* File share xmthcricket01 which guessing from the name represents the function app\n    * .nuget        (capture NuGet dependencies)\n    * .ssh          (for connectivity)\n    * data          (ASP.NET compilation snapshots, function secrets + sample data)\n    * LogFiles      (for if we opt to inject logging into our functions)\n    * site\n        * deployments   (deployment settings + history - will need to be tidied up at some point)\n        * diagnostics   (diagnostics settings)\n        * locks         (empty)\n        * repository    (source code depending on deployment approach)\n        * wwwroot       (The published function app itself)\n\nMakes sense, everything needed to make the app run is stored in a storage account we own, though don't need to actively manage (serverless).  \nI'm not going to worry too much about the details except that:  \n* For automation purposes we need to replace the wwwroot directory contents\n* Deployment history could build up and storage accounts are paid for by size, so cleanup may be required  \n\n\n## Create Function App with code\n\nThe most familiar way for me to create a C# HTTP trigger based function is the [dotnet CLI](https:\u002F\u002Fgithub.com\u002Fdotnet\u002Fcli):  \n``` dotnet new func ``` to create the project from within a target folder  \n``` dotnet new http ``` to create a new http trigger function within a function app project  \nProducing the structure seen in the [Azure functions C# Developer reference](https:\u002F\u002Fdocs.microsoft.com\u002Fen-us\u002Fazure\u002Fazure-functions\u002Ffunctions-dotnet-class-library).  \n\nIt is also possible using the [azure-functions-core-tools](https:\u002F\u002Fgithub.com\u002FAzure\u002Fazure-functions-core-tools):  \n``` func init ``` to create a function app, selecting a runtime (dotnet, selected from list)  \n``` func new ``` to create a function, C# httpTrigger  \n\nThe end result is very similar:  \n* .csproj with netcoreapp2.1 set as the target framework  \n* host.json with version set to \"2.0\"  \n* local.settings.json  \n\n```\n{\n    \"IsEncrypted\": false,\n    \"Values\": {\n        \"AzureWebJobsStorage\": \"\",\n        \"FUNCTIONS_WORKER_RUNTIME\": \"dotnet\"\n    }\n}\n```\n\n* A hello world sample function; Company.Function.http  \n\n```\n...\nusing Microsoft.Azure.WebJobs.Extensions.Http;\nusing Microsoft.Extensions.Logging;\nnamespace Company.Function\n{\n    public static class http\n    {\n        [FunctionName(\"http\")]\n        public static async Task\u003CIActionResult\u003E Run(\n            [HttpTrigger(AuthorizationLevel.Function, \"get\", \"post\", Route = null)] HttpRequest req,\n            ILogger log)\n        {\n            ...\n            string name = req.Query[\"name\"];\n            ...            \n            return name != null\n                ? (ActionResult)new OkObjectResult($\"Hello, {name}\")\n                : new BadRequestObjectResult(\"Please pass a name on the query string or in the request body\");\n        }\n    }\n}\n```\nSimple enough, an asynchronous JSON REST endpoint which accepts GET and POST methods, expects a \u002F route, does some basic validation and returns a response.  \nThis is .NET Core so no surprises that logging is available by dependency injection.  \nThis example has everything I need for now so no need to dwell on the details.  \nTime to build my own...  \n\n[Mth.Darts.Cricket.Api.StartMatch](https:\u002F\u002Fgithub.com\u002Fmtempleheald\u002Fcricket-azure\u002Fblob\u002Fmaster\u002FMth.Darts.Cricket.Api\u002FStartMatch.cs) should:\n* accept POST only\n* expect a route of \u002Fapi\u002Fmatches\n* expect parameters of scoring_mode, max_rounds and a list of \\[player\\[]], or a single json object containing all three\n* reference the domain service, specifically the Match constructor to get back a Match object, tested elsewhere\n* return a json object representing the Cricket match if all went well, an error message otherwise\n\n\n## Testing Azure functions\n\nThere are several different facets to testing here:\n1. Logic - nothing to do with serverless design but the most important part in my opinion\n2. Plumbing - does the function work as expected when called directly using an HttpRequest object?\n3. Routing - does an HTTP request get picked up by the expected function?\n4. Integration - When deployed does everything just work?\n\n### Testing logic\n\nNothing new here, create a test project using ``` dotnet new xunit ```  \nI did make things awkward for myself by restricting access on as much as possible so had to tweak the project to [make internals visible to the test project](https:\u002F\u002Fstackoverflow.com\u002Fquestions\u002F15440935\u002Fhow-to-test-internal-class-library#answer-15440997).  \n\n### Testing function plumbing\n\nNo need to repeat anything here, I followed the guide to [testing azure functions](https:\u002F\u002Fdocs.microsoft.com\u002Fen-us\u002Fazure\u002Fazure-functions\u002Ffunctions-test-a-function), extended it for multiple parameters and a different return value and used a JSON test file.  \n\n### Testing function routing\n\nIn REST terms a match can be considered a *resource*, a member of the matches *collection*.  \nTo create a match we need to pass parameters to the uri, repeating the player parameter as many times as required.  \nFor a 2 player match between Van Gerwen and Taylor we need to  \n```POST \u002Fapi\u002Fv1\u002Fmatches\u002F?scoring_mode=Standard&max_rounds=0&player[]=Van%20Gerwen&player[]=Taylor```  \nInitially there's no persistent data store, so this match isn't retrievable, but if it were it would be available at, e.g. \u002Fapi\u002Fv1\u002Fmatches\u002F123.  \nNote that I converted player to player\\[] in the url, because this is what AngularJS and some backend frameworks consider correct, though I can't find a definitive answer on the matter anywhere.  \n\nTo run Azure Functions locally from within the function app project use the Azure Functions Core Tools: ``` func start ```  \nI've opted to manually test routing using Postman for the MVP but intend to automate this eventually, using one of:\n* Postman CLI tool [Newman](https:\u002F\u002Flearning.getpostman.com\u002Fdocs\u002Fpostman\u002Fcollection_runs\u002Fcommand_line_integration_with_newman\u002F)\n* .Net Core [Integration tests](https:\u002F\u002Fdocs.microsoft.com\u002Fen-us\u002Faspnet\u002Fcore\u002Ftest\u002Fintegration-tests?view=aspnetcore-2.2)\n\n\n## Continuous Integration, Delivery & Deployment\n\nIn modern software development there is no excuse to not have some form of continuous integration (CI).  \nBuild and Test automation is usually easy and cheap to setup and pays for itself even in the short term.  \nIt is also entirely within the control of the software development team.  \nHow you implement this is dependent on the team and project requirements, for this project I'm just building on the master branch.  \n\nContinuous delivery is just as valuable, all projects should strive for some degree of this, but it is significantly harder to implement.  \nRelease automation complexity depends on the technology stack and collaboration with TechOps but the benefits far outweigh the costs.\n\nContinuous deployment takes this a step further, automating releases without human intervention, subject to quality gates from automated testing.  \nThis is a cultural thing, not all organisations or teams can work in this way for a myriad of reasons.  \nI can though, for this project, so that's the plan, straight to production after every build which passes tests.  \n\n\n## Build pipeline\n\nTwo mandatory requirements here:\n* Build automatically triggered every time the code is changed.\n* Build steps live with the code because who better to know how to build an application than the application developer?\nAnd one optional requirement:\n* Build should be target-agnostic for portability, to avoid vendor lock-in\n\nFocussing just on the mandatory requirements for the MVP I followed Microsoft's advice on [Linking Azure DevOps to GitHub](https:\u002F\u002Fdocs.microsoft.com\u002Fen-us\u002Fazure\u002Fdevops\u002Fpipelines\u002Frepos\u002Fgithub?view=vsts).  \nI chose the **GitHub App** option because I didn't want it linked directly to my credentials.\nIn GitHub **Azure Pipelines** now shows up under *Settings \u003E Integration & services \u003E Installed GitHub Apps* where I can configure it to restrict access to specific repositories or remove it altogether.  \nIn Azure DevOps **mtempleheald** now shows up under *Project Settings \u003E Pipelines \u003E Service Connections*, I can disconnect it here but it tells me that any configuration must be done on GitHub.  \n\nDuring this process a default [azure-pipelines.yml](https:\u002F\u002Fdocs.microsoft.com\u002Fen-us\u002Fazure\u002Fdevops\u002Fpipelines\u002Fprocess\u002Ftasks) file was presented to me with the option to commit it, which I accepted.  From here it didn't take long to configure a working build by chaining dotnet CLI commands together.  \nIt is very easy to break a build so having this set up early on is really important for stability, I'd say that this is step 1 on the way to true DevOps, where the developers take responsibility for handover of artifacts.  \nSome nice visual feedback and convenient logging, plus a status badge is available for the project \n[![Build Status](https:\u002F\u002Fdev.azure.com\u002Fmtempleheald\u002Fcricket-azure\u002F_apis\u002Fbuild\u002Fstatus\u002Fmtempleheald.cricket-azure?branchName=master)](https:\u002F\u002Fdev.azure.com\u002Fmtempleheald\u002Fcricket-azure\u002F_build\u002Flatest?definitionId=1?branchName=master)\n\n### Build steps\n\nBuild steps used:\n* script: ``` dotnet --version ``` - check that we know which version of .NET lives on the Microsoft-managed build agent\n* script: ``` dotnet build '\u003Cproject\u003E' --configuration $(buildConfiguration) ``` - build a named project\n* task: ``` DotNetCoreCLI@2 ``` - run tests\n* script: ``` dotnet publish '\u003Cfunction_app_project\u003E' --output '\u003Ctarget_dir\u003E' ``` - prepare function app artifacts for publication\n* task: ``` CopyFiles@2 ``` - copy specified files to artifact drop location\n* task: ``` PublishBuildArtifacts@1 ``` - publish the artifacts ready for the release pipeline\n\noutput of dotnet publish:\n* FunctionApp\n    * bin\u002F\n    * StartMatch\n        * function.json\n    * host.json\n    * *.deps.json\nwhich seems to match the [continuous deployment requirements](https:\u002F\u002Fdocs.microsoft.com\u002Fen-gb\u002Fazure\u002Fazure-functions\u002Ffunctions-continuous-deployment#continuous-deployment-requirements).  \nWhat this doesn't make clear however is that the top level folder is not expected within the zip file.  \nThis is important as it means that the build pipeline does not need to provide the name for the deployed artifact and facilitates a multi-environment deployment from a single build artifact (assuming everything else is parameterised appropriately).  \n\n\n## Azure DevOps Artifacts\n\nIt is good practice to keep build and release steps separate [The 12 Factor App](https:\u002F\u002F12factor.net\u002Fbuild-release-run).  \nThis makes sense, there may be some overlap but build steps are developer controlled and release steps are about environment config and is more of a TechOps role unless you truly embrace DevOps.  \n\nIn the terminology of Azure DevOps I need to publish an **artifact** on the **build pipeline** to make it available to the **release pipeline**.  \nThis is simple, but very easy to make mistakes, so it is useful to be able to debug pipeline execution.  \n\nIt helps to understand how files are stored on the build\u002Frelease agents, [pre-defined variables](https:\u002F\u002Fdocs.microsoft.com\u002Fen-us\u002Fazure\u002Fdevops\u002Fpipelines\u002Fbuild\u002Fvariables?view=vsts)  \n\n| Path structure    | System.                                    | Build.                                    | Agent.                   |\n| ----------------- | ------------------------------------------ | ----------------------------------------- | ------------------------ |\n| \u002Fagent\u002F           |                                            |                                           | HomeDirectory            |\n| \u002Fagent\u002Fwork\u002F      | WorkFolder                                 |                                           | RootDirectory WorkFolder |\n| \u002Fagent\u002Fwork\u002F1     |                                            |                                           | BuildDirectory           |\n| \u002Fagent\u002Fwork\u002F1\u002Fs   | DefaultWorkingDirectory                    | SourcesDirectory                          |                          |\n| \u002Fagent\u002Fwork\u002F1\u002Fb   |                                            | BinariesDirectory                         |                          |\n| \u002Fagent\u002Fwork\u002F1\u002Fa   |                                            | ArtifactStagingDirectory StagingDirectory |                          |\n| \u002Fagent\u002Fwork\u002Fr1\u002Fa  | ArtifactsDirectory DefaultWorkingDirectory |                                           | ReleaseDirectory         |\n\nMost of these steps provide useful information but if it isn't enough we can add extra debug information:  \n* To debug build steps add ``` system.debug: true ``` to azure-pipelines.yml.  \n* To debug release steps add *system.debug* to the Variables tab on the UI, with a value of true.  \n\nA notable issue I had was with the release pipeline being unable to find the published function app artifact, despite triple-checking paths and successful step execution:\n* Zip up function app - *Successfully created archive: \u002Fhome\u002Fvsts\u002Fwork\u002F1\u002Fa\u002F11.zip*\n* Publish Build Artifacts - no listed output (suspicious but successful)\n\nIt turns out that the publish step was failing silently because I'd put an incorrect parameter in.  I only figured this out by looking at the [source code](https:\u002F\u002Fgithub.com\u002FMicrosoft\u002Fazure-pipelines-tasks\u002Fblob\u002Fmaster\u002FTasks\u002FPublishBuildArtifactsV1\u002Fpublishbuildartifacts.ts) of the suspicious step.  There are 2 allowed values for artifactType; 'Container' and 'FilePath'.  Turns out I'd been passing the description of container instead ('Azure Pipelines\u002FTFS') - oops!\n\n* Publish Build Artifacts - *Upload '\u002Fhome\u002Fvsts\u002Fwork\u002F1\u002Fa' to file container: '#\u002F2495698\u002Fdrop'* - success!\n\n\n## Release pipeline\n\nAzure DevOps release pipelines currently work differently from build pipelines, although release pipeline Configuration as code (YAML) is [planned for 2018 Q4](https:\u002F\u002Fdev.azure.com\u002Fmseng\u002FAzure%20DevOps%20Roadmap\u002F_workitems\u002Fedit\u002F1221170).  \nThat being said, tasks are common but categorised (build, utility, test, package, deploy, tool) - [code](https:\u002F\u002Fgithub.com\u002FMicrosoft\u002Fazure-pipelines-tasks\u002Ftree\u002Fmaster\u002FTasks).  \nSo there is nothing stopping me from adding release steps to the azure-pipelines.yml file above, but I'm going to do it properly instead, keeping build and release separate by using the published artifacts.  \n\n### Connecting the release pipeline to Azure\n\nThe Azure Portal function app page has a *Deployment Center* tab, where you can configure a Git repository connection.  \nThis uses [Kudo](https:\u002F\u002Fgithub.com\u002Fprojectkudu\u002Fkudu) which by default expects either 1 solution or 1 project to deploy, but can be [customised](https:\u002F\u002Fgithub.com\u002Fprojectkudu\u002Fkudu\u002Fwiki\u002FCustomizing-deployments).   \nIt can also be customised in the Azure portal, by adding the target project (*PROJECT = function-app\u002Ffunction-app.csproj*)  \nto application settings *Azure \u003E Overview \u003E Application Settings \u003E Application Settings*\nI'm uncomfortable with this approach for several reasons:\n* The GitHub connection is tied directly to my account\n* This configuration is hidden away and easily forgotten, though I could address this using the custom .deployment file in the code.  \n* What about the other elements of the release?  Storage, static content, I want consistency in my releases.\n\nThe better approach is to manage releases within an independent release pipeline (Azure DevOps), even when aiming for continuous deployment.  \nThis requires setting up an Azure Resource Manager (ARM) connection:  \n*Azure DevOps \u003E Project Settings \u003E Pipelines \u003E Service Connections \u003E New Service Connection \u003E Azure Resource Manager*  \nFor which I had to [create a service principal](https:\u002F\u002Fdocs.microsoft.com\u002Fen-gb\u002Fazure\u002Factive-directory\u002Fdevelop\u002Fhowto-create-service-principal-portal):  \n1. Azure Portal \u003E App Registrations \u003E Create \u003E Web App (url not important yet)\n2. Azure Portal \u003E Subscriptions \u003E ~MySubscription~ \u003E IAM \u003E Add role assignment \u003E Contributor + App name\n\nI could now access the parameters required to add the connection:  \n* Tenant-Id:  \n  Azure Portal \u003E Azure Active Directory \u003E Properties \u003E Directory ID\n* Application ID:  \n  Azure Portal \u003E App Registrations \u003E ~My App~ \u003E Application ID\n* Authentication Key:  \n  Azure Portal \u003E App Registrations \u003E ~My App~ \u003E Settings \u003E Keys\n\nHereafter release pipeline tasks simply need to refer to this connection and it just works.\n\n### Release pipeline steps \n\n* [ARM deployment](https:\u002F\u002Fgithub.com\u002FMicrosoft\u002Fazure-pipelines-tasks\u002Fblob\u002Fmaster\u002FTasks\u002FAzureResourceGroupDeploymentV2\u002FREADME.md) - all infrastructure elements within the resource group, the equivalent of using the command line tools:  \n```\n$resourceGroup = 'mthtest01'\n$storageAccount = \"$($resourceGroup)apistorage\"\n$appServiceplan = \"$($resourceGroup)plan\"\n$functionApp = \"$($resourceGroup)api\"\naz group create --name $resourceGroup --location westeurope\naz storage account create --name $storageAccount --location westeurope --resource-group $resourceGroup --sku Standard_LRS\naz appservice plan create --name $appServiceplan --resource-group $resourceGroup --sku B1 --is-linux\naz functionapp create --resource-group $resourceGroup --plan $appServiceplan --name $functionApp --storage-account $storageAccount --runtime dotnet\n```\n* [Azure App Service Deploy (Preview)](https:\u002F\u002Faka.ms\u002Fazurermwebdeployreadme) - azure function deployment to function app\n* [Azure File Copy (Preview)](https:\u002F\u002Faka.ms\u002Fazurefilecopyreadme) - static website copied to $web blob container\n* [Azure CLI](https:\u002F\u002Fgithub.com\u002FMicrosoft\u002Fazure-pipelines-tasks\u002Fblob\u002Fmaster\u002FTasks\u002FAzureCLIV1\u002FReadme.md) - using the az command line tools to turn the blob container into a static website:  \n```\naz extension add --name storage-preview --debug\naz storage blob service-properties update --account-name \"$(resourceGroup)ui\" --static-website --404-document 404.html --index-document index.html --debug\n```\n\n## ARM templates for continuous deployment\n\nI have come across ARM templates before and know that they're the recommended approach for (re)deploying Azure artifacts in a consistent fashion, but I've never built any from scratch, so it is time to investigate.  My aim here is to develop a pattern which I can use again for another serverless app in Azure, without having to think about this stuff again.  This has been easily the most time-consuming part of this project.  \n\nI want a single ARM template containing all aspects of the serverless application MVP:\n* Storage account for static file hosting\n* Storage account for function app support\n* Function app (It is possible but makes little sense to [deploy functions themselves using ARM](https:\u002F\u002Fblog.kloud.com.au\u002F2018\u002F08\u002F16\u002Fdeploying-azure-functions-with-arm-templates\u002F))\n\nARM [template structure](https:\u002F\u002Fdocs.microsoft.com\u002Fen-gb\u002Fazure\u002Fazure-resource-manager\u002Fresource-group-authoring-templates):\n* parameters    - passed on execution, e.g. environment\u002F version\u002F build number\n* variables     - build upon parameters and group names together for consistency\n* functions     - user-defined functions\n* resources     - deploy stuff - [intro](https:\u002F\u002Fdocs.microsoft.com\u002Fen-gb\u002Fazure\u002Fazure-resource-manager\u002Fresource-manager-templates-resources)\n* outputs       - capture values from during execution in case further processing required, e.g. url available\n\nThere are some useful [quickStart templates](https:\u002F\u002Fgithub.com\u002FAzure\u002Fazure-quickstart-templates) to learn from, specifically [101-storage-account-create](https:\u002F\u002Fraw.githubusercontent.com\u002FAzure\u002Fazure-quickstart-templates\u002Fmaster\u002F101-storage-account-create\u002Fazuredeploy.json) and [101-function-app-create-dynamic](https:\u002F\u002Fgithub.com\u002FAzure\u002Fazure-quickstart-templates\u002Fblob\u002Fmaster\u002F101-function-app-create-dynamic\u002Fazuredeploy.json).  \nIt can also be useful to create stuff manually once and view the generated script:  \nAzure Portal \u003E Resource Groups \u003E %Resource Group% \u003E Automation Script  \n\nI also found it useful to briefly look at the REST APIs which ARM deployment use under the hood:  \n* [storage account REST API](https:\u002F\u002Fdocs.microsoft.com\u002Fen-us\u002Frest\u002Fapi\u002Fstoragerp\u002Fstorageaccounts)  \n* [webapps REST API](https:\u002F\u002Fdocs.microsoft.com\u002Fen-us\u002Frest\u002Fapi\u002Fappservice\u002Fwebapps)  \n\n### Preparing the ARM template\n\nStarting with naming I want the following visible in the Azure Portal:\n* mthcricket01 (resource group)\n* mthcricket01api (function app)\n* mthcricket01apistorage (storage account required by function app)\n* mthcricket01ui (storage account for static content)\n\nThis is easily achieved using variables:  \n```JSON\n\"variables\": {\n        \"functionApp\": \"[concat(resourceGroup().name, 'api')]\",\n        \"functionAppStorage\": \"[concat(resourceGroup().name, 'apistorage')]\",\n        \"uiStorage\": \"[concat(resourceGroup().name, 'ui')]\"\n    }\n```\n\nThe real details are in the resources section and this can get quite complicated; you have to learn Azure terminology, relationships and specify API versions.  \nI've found the most useful information in the [Azure template reference](https:\u002F\u002Fdocs.microsoft.com\u002Fen-us\u002Fazure\u002Ftemplates) where apiVersion options are clear.  \nThis is also available through Azure PowerShell:\n\n```\n(Get-AzResourceProvider -ProviderNamespace Microsoft.Storage).ResourceTypes | Where {$_.ResourceTypeName -eq 'storageAccounts'} | select -ExpandProperty ApiVersions\n2018-07-01\n2018-03-01-preview\n...\n2015-05-01-preview\n(Get-AzResourceProvider -ProviderNamespace Microsoft.Web).ResourceTypes | Where {$_.ResourceTypeName -eq 'sites'} | select -ExpandProperty ApiVersions\n(Get-AzResourceProvider -ProviderNamespace Microsoft.Web).ResourceTypes | Where {$_.ResourceTypeName -eq 'serverfarms'} | select -ExpandProperty ApiVersions\n(Get-AzResourceProvider -ProviderNamespace Microsoft.Web).ResourceTypes | Where {$_.ResourceTypeName -eq 'functions'} | select -ExpandProperty ApiVersions\n2018-11-01\n2018-02-01\n...\n2014-04-01\n```\n\nIt took me a long time to get to grips with apiVersion, in the end I realised that it was the tooling in VS Code that was causing the confusion with unnecessary warnings, I learnt to instead just perform a test run in PowerShell (requires the [Azure PowerShell module](https:\u002F\u002Fdocs.microsoft.com\u002Fen-gb\u002Fpowershell\u002Fazure\u002Finstall-az-ps?view=azps-1.0.0&viewFallbackFrom=azurermps-4.0.0)):  \n\n```\nConnect-AzAccount\nSelect-AzSubscription -SubscriptionName 'Free Trial'\nNew-AzResourceGroup -Name $resourceGroupName -Location 'North Europe'\nTest-AzResourceGroupDeployment -ResourceGroupName $resourceGroupName -TemplateFile .\\azuredeploy.json -Debug\n```\n\nIt is possible to have the template refer to the latest version, using ``` [providers('\u003Cprovider\u003E','\u003Ctype\u003E').apiVersions[0]] ``` but this opens you up to breaking changes, so I'm avoiding that route.  I do think that it is important to be on the latest version you can be, this is a process thing, add the upgrade step into any future template update tasks.  \nOnce I was comfortable that I knew which versions I was aiming for I was able to get it done:  \n* [Function App](https:\u002F\u002Fdocs.microsoft.com\u002Fen-us\u002Fazure\u002Ftemplates\u002Fmicrosoft.web\u002F2018-02-01\u002Fsites)\n* [Hosting Plan for function app](https:\u002F\u002Fdocs.microsoft.com\u002Fen-us\u002Fazure\u002Ftemplates\u002Fmicrosoft.web\u002F2018-02-01\u002Fserverfarms)\n* [Storage Account](https:\u002F\u002Fdocs.microsoft.com\u002Fen-us\u002Fazure\u002Ftemplates\u002Fmicrosoft.storage\u002F2018-07-01\u002Fstorageaccounts)\n\nAnother awkward bit is configuring the [App Settings for Azure Functions](https:\u002F\u002Fdocs.microsoft.com\u002Fen-gb\u002Fazure\u002Fazure-functions\u002Ffunctions-app-settings).  \nproperties \u003E siteConfig \u003E appSettings:\n* AzureWebJobsStorage == *(DefaultEndpointsProtocol=https;AccountName=[name];AccountKey=[key])*\n* AzureWebJobsDashboard == *(DefaultEndpointsProtocol=https;AccountName=[name];AccountKey=[key])*\n* WEBSITE_CONTENTAZUREFILECONNECTIONSTRING == *(DefaultEndpointsProtocol=https;AccountName=[name];AccountKey=[key])*\n* WEBSITE_CONTENTSHARE == *mthcricket01api*\n* AzureWebJobsDisableHomepage == *true*\n* FUNCTIONS_EXTENSION_VERSION == *~2*\n* FUNCTIONS_WORKER_RUNTIME == *dotnet*\n* AzureWebJobsDotNetReleaseCompilation == *false* (for debugging)\n* APPINSIGHTS_INSTRUMENTATIONKEY == *plan* \n\nI'm still working through the nuances of functionapp deployment, I'm getting internal server errors from Azure on the 2nd run through, having deployed fine the 1st run through.  The difficulty is primarily because this stuff is quite new and in flux, there are changes between [Runtime version 1 vs 2](https:\u002F\u002Fdocs.microsoft.com\u002Fen-us\u002Fazure\u002Fazure-functions\u002Ffunctions-versions) plus I've chosen some awkward options like Linux hosting.  \n\nI opted part way through to adopt [Template Linking](https:\u002F\u002Fdocs.microsoft.com\u002Fen-us\u002Fazure\u002Fazure-resource-manager\u002Fresource-group-linked-templates).  \nThis was simply because the template was already becoming uncomfortably long though I'm not sure this helped for my small project.  \nThis didn't add too much complexity either, mostly moving the *DependsOn*  settings from the resource itself, to the deployment of the resource and providing template outputs.  \n\nI prefer this in principle because it is more modular.  For example the functionapp depends on the storage account connection string.  To get this you need to access the storage account API to get the key:  \n``` \"value\": \"[listKeys(variables('StorageAccountName'), providers('Microsoft.Storage', 'storageAccounts').apiVersions[0])]\" ```  \nThe equivalent in PowerShell: ``` (Get-AzStorageAccountKey -ResourceGroupName \u003Cresource-group\u003E -Name \u003Cstorage-account\u003E).key1 ```  \nIt feels right to me that this lives within the storage account creation template, not the function app, otherwise both templates need to manage apiVersions for the storage account API (although this example just uses latest).\n\n\n## Costs\n\nThis was never meant to be a serious production application, I'm certainly not expecting it to scale to fully utilise serverless scaling capabilities.  \nMy intention was to use the [consumption plan](https:\u002F\u002Fazure.microsoft.com\u002Fen-gb\u002Fpricing\u002Fdetails\u002Fapp-service\u002Fplans\u002F), therefore I was expecting it to be free or very close to.    \nWhat I actually witnessed was that in the couple of weeks that I've had something running I accrued £0.09 on API storage and nearly £5 on an App Service Plan.  I've now addressed this, the ARM template was wrong, fixed by manually recreating all, viewing the generated Azure *automation script* and tweaking settings accordingly.\n\n\n## Summary\n\nThis project has been fairly successful so far, zero to [Live application](https:\u002F\u002Fmthcricket01ui.z16.web.core.windows.net\u002F) in under a month.  \nI've also quite enjoyed bringing together lots of different elements I've used to varying degrees to build something real.\n\nIt isn't perfect of course, there are some known issues:\n* ~~Scores continue adding on even if all ticked off - API logic wrong~~ Fixed\n* ~~Plan costing money, something isn't right about the functionapp deployment yet, consumption plan should be free (at low volumes).~~\n* Clicking too quickly misrepresents the status as evidenced by the history of throws - 2 choices (possibly both):\n    * throttling within Angular controller, checksum-esque, possibly store actions in local queue before calling API (web worker?)\n    * incremement version within the API, check that requests are received in order, depends upon data persistence but may be better solution\n* Skip function totally broken (symptom of the above)\n* Initial load is extremely slow (several seconds) and it *appears* to be broken.  Possibly send a dummy request in the background to hide this from the user.\n* Buttons jump about a bit due to flexbox\u002F grid layout and conditional display of skip, would be nice to fix this\n\nThere's also outstanding work to do:  \n* Deployments building up in storage, no need to keep history of deployments so need to add clear step to release pipeline (start).\n* Better understand Azure's inner workings, or terminology at least, I feel that I'm missing something (or the documentation is).  Possibly I'm just more pedantic than most users, I want to understand it, not just get it working."}</script></div>
	</body>
</html>
