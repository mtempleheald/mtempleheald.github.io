<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="/favicon.ico" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />

		<meta http-equiv="content-security-policy" content="">
	<link rel="stylesheet" href="/_app/assets/pages/__layout.svelte-711b4112.css">
	<link rel="modulepreload" href="/_app/start-7208c571.js">
	<link rel="modulepreload" href="/_app/chunks/vendor-5ca848cc.js">
	<link rel="modulepreload" href="/_app/pages/__layout.svelte-8da8bfc2.js">
	<link rel="modulepreload" href="/_app/pages/blog/_slug_.svelte-db98abb9.js">
	</head>
	<body>
		<div>



<div class="svelte-1lrvsco"><header><h1 class="svelte-1lrvsco">Mark Temple-Heald</h1>
  <h2 class="svelte-1lrvsco">the right tool for the job</h2></header>

<nav class="svelte-r02kv1"><ul class="svelte-r02kv1"><li class="svelte-r02kv1"><a href="/" class="navAnchor">Home</a></li>
    <li class="svelte-r02kv1"><a href="/blog" class="navAnchor">Blog</a></li>
    <li class="svelte-r02kv1"><a href="/topic" class="navAnchor">Topic</a></li>
    <li class="svelte-r02kv1"><a href="/about" class="navAnchor">About</a></li></ul>
</nav>
</div>

<main class="svelte-lv7236"><!-- HTML_TAG_START -->I recently read the <em>The Data Warehouse Toolkit (Second Edition)</em> before embarking on a project to implement a new data warehouse.<br />I recommend reading this book, it is clear, detailed and accessible, but here is a super succinct summary for my own benefit.<h4>Fact tables</h4><ul><li>few columns, many rows</li><li>always at lowest level (granular) detail</li></ul><pre class="code poetry"><code>* lowest level of detail required for business reporting, not necessarily the lowest level grain held by the source system</code></pre><ul><li>typically try to avoid semi-additive facts (e.g. balance)</li><li>always avoid to-date totals, not consistent with the grain</li><li>try to avoid textual facts</li></ul><pre class="code poetry"><code>* tend to be filtered out into a separate dimension (mini dimension)</code></pre><h4>Factless fact tables</h4><ul><li>convenient representation of many-many relationships between dimensions, even if there is no obvious numeric fact at that level</li><li>may wish to add artificial fact (always == 1) to clarify queries</li></ul><h4>Coverage tables</h4><ul><li>special form of factless fact table</li><li>one row per dimension Cartesian product, regardless of occupation, flag to indicate available/ in use</li><li>There is a data overhead involved in doing this so it is only for special uses</li></ul><h4>Dimension tables</h4><ul><li>few rows, many columns</li><li>denormalised extensively – few rows => small impact in size compared with performance improvements</li><li>Avoid snowflaking (normalising of dimensions) – will slow queries</li><li>Need surrogate key (SKey) to uniquely identify a row even if a suitable business key exists, future proofing</li><li>Need getSKey function for each dim (based on natural key)</li><li>Cater for null values using a “-1” entry</li><li>Typically expect 5-15 dimensions per dimensional model</li></ul><h4>Date dimension</h4><ul><li>1 row per day</li><li>Day, week, month, quarter, year info on each line</li><li>Easier filtering/ formatting than SQL date conversion functions</li><li>The ONLY dimension with a meaningful key – in date order</li><li>This predictability is important for partitioning, backups and restorations, whereby all rows relating to a date range should be partitioned together</li></ul><h4>Data Modelling Approach</h4><br /><ul><li>Separate ERD(s) into business processes & model separately</li><li>Many-many tables become facts</li><li>Denormalise remaining tables – become dimensions</li><li>Convert identifiers into meaningful data e.g. ‘M’ becomes ‘Male’</li><li>Agree on these “conformed” dimensions and seek to reuse</li><li>Likewise seek to use conformed facts with standard, meaningful attributes</li></ul><h4>Maintaining the DW Bus Matrix</h4><ul><li>Business process (data mart = set of closely-related fact tables) vs common dimensions.  This is a very high level planning aid (p79)</li><li>Enables coherent vision of DW architecture</li><li>Can extend to include fact table/ granularity/ facts for full picture.  This is more closely tied to the implementation phase (p321)</li></ul><h4>Conformed dimensions</h4><ul><li>Agreed business nomenclature to avoid redundancy and inaccuracy</li><li>Common columns are identical</li><li>1 may have extra columns e.g. confidential information</li><li>1 may have extra rows (subset of data) –be careful re. referential integrity</li></ul><h4>Slowly Changing Dimensions (SCD)</h4><ul><li>Type 1 – overwrite old version – lose history</li><li>Type 2 – create new dim row – keep history but cannot look at both together</li><li>Type 3 – consider 2 (or 3…) previous versions</li></ul><pre class="code poetry"><code>* require fact column for each version
* can compare versions as of date X</code></pre><ul><li>Combinations of the above</li></ul><h4>Role-Playing dimensions</h4><ul><li>When need 2 dates on a table need 2 references to Date Dim.<br />Cant refer to same table twice so use views instead</li><li>Applicable to other dimensions but common with date dimension</li></ul><h4>Dimension Outriggers</h4><ul><li>Constitutes normalisation of dimensions – use sparingly</li><li>Useful when dimensions of significantly differing grain and main dimension is large  </li></ul>
  e.g. customers + demographics (age, gender etc)<ul><li>Location is a valid candidate for an outrigger – can use GIS tools too</li></ul><h4>Degenerate dimensions</h4><ul><li>Number left in fact table without corresponding dim table.</li></ul><pre class="code poetry"><code>Can be later expanded to a dimension if required (but use surrogate keys then!)
Can be grouped/ filtered in the meantime.</code></pre><ul><li>If dimension contains similar numbers of rows to the fact table, </li></ul><pre class="code poetry"><code>this may be a good candidate for a degenerate dimension</code></pre><h4>Junk dimensions</h4><ul><li>Groups of typically low-cardinality flags</li><li>may look like Cartesian product but with a surrogate key</li><li>can be used to reduce the number of columns in a fact table, potentially space-saving.</li></ul><h4>Mini dimensions</h4><ul><li>Separate textual fact out from fact table into mini dimension.</li><li>Enabled high-performance filtering of data</li></ul><h4>Header/Line facts with different granularity</h4><ul><li>Remove higher-level fact table by duplicating facts from the higher-level header fact row down to lower-level line fact row(s), much like dimension denormalisation</li><li>Or maintain both tables at different granularity (only when necessary)</li></ul><h4>Real-Time Partitions</h4><ul><li>Physically & administratively separate “partition” (different tables) from the rest of the warehouse.</li><li>Contains all activity since last standard ETL run, same structure as standard DW tables.</li></ul><h4>Bridge tables (p164) </h4><ul><li>For variable-depth hierarchies</li><li>May contain parent skey, subsidiary skey, level, bottom flag, top flag</li><li>Can create view new<em>fact = bridge + fact to hide complexity</li><li>Combine with a weighting factor attribute on the bridge table, summed over the group it should always equal 1</em></li></ul><h4>Audit Dimension</h4><ul><li>Source system, ETL version, confidences</li><li>use skey to link to rows updated by that particular ETL run</li></ul><h4>Keyword Outrigger Dimension</h4><ul><li>Attribute such as '\\UNIX\\LINUX\\SQL\\' for skills for a person</li><li>Can filter using LIKE '%\\SQL\\%' (avoids complicated union views)</li></ul><h4>Superdimension (similar to junk dimension)</h4><ul><li>Combine 2 or more dimensions into a single dimension.  </li></ul>
  This is likely to be a Cartesian product and is suitable only for small date volumes<ul><li>E.g. flights – class flown != class purchased (up/downgrades), create superdimension with 9 rows (coach/business/first)^2</li></ul><h4>Fact Dimension</h4><ul><li>For sparse fact tables, i.e. groups of attributes often empty</li><li>separate these attribute groups into separate fact dimensions and link with surrogate key</li><li>Allows us to keep fact table structure static, no new columns</li><li>Very flexible but may expand too quickly if facts become less sparse</li><li>may considerably complicate data access</li><li>Type + content dimensions to handle heterogeneous products</li></ul><h4>Late-arriving fact rows</h4><ul><li>For each dimension establish surrogate key based on natural key (plus SCD effective dates)</li><li>insert into correct physical partition based on date</li><li>If historical data cannot change (has been reported, though inaccurate) </li></ul><pre class="code poetry"><code>then may need 2 sets of dates  (operational/ booking)</code></pre><h4>Late-arriving dimension rows (applied to slowly changing dimensions)</h4><ul><li>Insert new row with new surrogate key</li><li>Scan forwards from this date and correct later rows with same natural key</li><li>Update all fact rows to correct surrogate key</li></ul><br />The summary of traps to avoid on P326 is well worth reading too.<br />In order to improve performance of the ETL you can use a cyclic redundancy checksum (CRC) algorithm on dimension staging tables.<br />This is a more efficient way to determine if row has been updated than comparing each column. <!-- HTML_TAG_END --></main>


<footer class="svelte-14g1sgx"><p>This is my site, there are many like it but this one is mine.</p>
  <p>If you don&#39;t like it, you know where the close button is.</p>
  <a href="https://www.linkedin.com/in/mtempleheald" target="_blank" class="svelte-14g1sgx">Mark Temple-Heald</a>
  <a href="https://mtempleheald.github.io" target="_blank" class="svelte-14g1sgx">Home</a>
  <a href="https://github.com/mtempleheald" target="_blank" class="svelte-14g1sgx">GitHub</a>
  <p>Mindful meanderings manifest more manageable machinations.
    Manoeuvring murky multifaceted modernism means meticulously managing many mistakes, misconceptions, misunderstandings.
    Measured multipronged musings, mechanical movements, may maximise meritorious magnificence.
  </p>
</footer>


		<script type="module" data-hydrate="1aoyq73">
		import { start } from "/_app/start-7208c571.js";
		start({
			target: document.querySelector('[data-hydrate="1aoyq73"]').parentNode,
			paths: {"base":"","assets":""},
			session: {},
			route: true,
			spa: false,
			trailing_slash: "never",
			hydrate: {
				status: 200,
				error: null,
				nodes: [
					import("/_app/pages/__layout.svelte-8da8bfc2.js"),
						import("/_app/pages/blog/_slug_.svelte-db98abb9.js")
				],
				url: new URL("http://sveltekit-prerender/blog/2011-08-01-Data-Warehouse-Toolkit-Summary"),
				params: {slug:"2011-08-01-Data-Warehouse-Toolkit-Summary"}
			}
		});
	</script><script type="application/json" data-type="svelte-data" data-url="/api/blogs/2011-08-01-Data-Warehouse-Toolkit-Summary">{"status":200,"statusText":"","headers":{"content-type":"text/plain;charset=UTF-8"},"body":"I recently read the *The Data Warehouse Toolkit (Second Edition)* before embarking on a project to implement a new data warehouse.  \nI recommend reading this book, it is clear, detailed and accessible, but here is a super succinct summary for my own benefit.\n\n#### Fact tables\n\n* few columns, many rows\n* always at lowest level (granular) detail\n    * lowest level of detail required for business reporting, not necessarily the lowest level grain held by the source system\n* typically try to avoid semi-additive facts (e.g. balance)\n* always avoid to-date totals, not consistent with the grain\n* try to avoid textual facts\n    * tend to be filtered out into a separate dimension (mini dimension)\n\n#### Factless fact tables\n\n* convenient representation of many-many relationships between dimensions, even if there is no obvious numeric fact at that level\n* may wish to add artificial fact (always == 1) to clarify queries\n\n#### Coverage tables\n\n* special form of factless fact table\n* one row per dimension Cartesian product, regardless of occupation, flag to indicate available\u002F in use\n* There is a data overhead involved in doing this so it is only for special uses\n\n#### Dimension tables\n\n* few rows, many columns\n* denormalised extensively – few rows =\u003E small impact in size compared with performance improvements\n* Avoid snowflaking (normalising of dimensions) – will slow queries\n* Need surrogate key (SKey) to uniquely identify a row even if a suitable business key exists, future proofing\n* Need getSKey function for each dim (based on natural key)\n* Cater for null values using a “-1” entry\n* Typically expect 5-15 dimensions per dimensional model\n\n#### Date dimension\n* 1 row per day\n* Day, week, month, quarter, year info on each line\n* Easier filtering\u002F formatting than SQL date conversion functions\n* The ONLY dimension with a meaningful key – in date order\n* This predictability is important for partitioning, backups and restorations, whereby all rows relating to a date range should be partitioned together\n\n#### Data Modelling Approach\n  \n* Separate ERD(s) into business processes & model separately\n* Many-many tables become facts\n* Denormalise remaining tables – become dimensions\n* Convert identifiers into meaningful data e.g. ‘M’ becomes ‘Male’\n* Agree on these “conformed” dimensions and seek to reuse\n* Likewise seek to use conformed facts with standard, meaningful attributes\n\n#### Maintaining the DW Bus Matrix\n\n* Business process (data mart = set of closely-related fact tables) vs common dimensions.  This is a very high level planning aid (p79)\n* Enables coherent vision of DW architecture\n* Can extend to include fact table\u002F granularity\u002F facts for full picture.  This is more closely tied to the implementation phase (p321)\n\n#### Conformed dimensions\n\n* Agreed business nomenclature to avoid redundancy and inaccuracy\n* Common columns are identical\n* 1 may have extra columns e.g. confidential information\n* 1 may have extra rows (subset of data) –be careful re. referential integrity\n\n#### Slowly Changing Dimensions (SCD)\n\n* Type 1 – overwrite old version – lose history\n* Type 2 – create new dim row – keep history but cannot look at both together\n* Type 3 – consider 2 (or 3…) previous versions\n    * require fact column for each version\n    * can compare versions as of date X\n* Combinations of the above\n\n#### Role-Playing dimensions\n\n* When need 2 dates on a table need 2 references to Date Dim.  \n* Cant refer to same table twice so use views instead\n* Applicable to other dimensions but common with date dimension\n\n#### Dimension Outriggers\n\n* Constitutes normalisation of dimensions – use sparingly\n* Useful when dimensions of significantly differing grain and main dimension is large  \n  e.g. customers + demographics (age, gender etc)\n* Location is a valid candidate for an outrigger – can use GIS tools too\n\n#### Degenerate dimensions\n\n* Number left in fact table without corresponding dim table.\n    Can be later expanded to a dimension if required (but use surrogate keys then!)\n    Can be grouped\u002F filtered in the meantime.\n* If dimension contains similar numbers of rows to the fact table, \n    this may be a good candidate for a degenerate dimension\n\n#### Junk dimensions\n\n* Groups of typically low-cardinality flags\n* may look like Cartesian product but with a surrogate key\n* can be used to reduce the number of columns in a fact table, potentially space-saving.\n\n#### Mini dimensions\n\n* Separate textual fact out from fact table into mini dimension.\n* Enabled high-performance filtering of data\n\n#### Header\u002FLine facts with different granularity\n\n* Remove higher-level fact table by duplicating facts from the higher-level header fact row down to lower-level line fact row(s), much like dimension denormalisation\n* Or maintain both tables at different granularity (only when necessary)\n\n#### Real-Time Partitions\n\n* Physically & administratively separate “partition” (different tables) from the rest of the warehouse.\n* Contains all activity since last standard ETL run, same structure as standard DW tables.\n\n#### Bridge tables (p164) \n\n* For variable-depth hierarchies\n* May contain parent skey, subsidiary skey, level, bottom flag, top flag\n* Can create view new_fact = bridge + fact to hide complexity\n* Combine with a weighting factor attribute on the bridge table, summed over the group it should always equal 1\n\n#### Audit Dimension\n\n* Source system, ETL version, confidences\n* use skey to link to rows updated by that particular ETL run\n\n#### Keyword Outrigger Dimension\n\n* Attribute such as '\\\\UNIX\\\\LINUX\\\\SQL\\\\' for skills for a person\n* Can filter using LIKE '%\\\\SQL\\\\%' (avoids complicated union views)\n\n#### Superdimension (similar to junk dimension)\n\n* Combine 2 or more dimensions into a single dimension.  \n  This is likely to be a Cartesian product and is suitable only for small date volumes\n* E.g. flights – class flown != class purchased (up\u002Fdowngrades), create superdimension with 9 rows (coach\u002Fbusiness\u002Ffirst)^2\n\n#### Fact Dimension\n\n* For sparse fact tables, i.e. groups of attributes often empty\n* separate these attribute groups into separate fact dimensions and link with surrogate key\n* Allows us to keep fact table structure static, no new columns\n* Very flexible but may expand too quickly if facts become less sparse\n* may considerably complicate data access\n* Type + content dimensions to handle heterogeneous products\n\n#### Late-arriving fact rows\n\n* For each dimension establish surrogate key based on natural key (plus SCD effective dates)\n* insert into correct physical partition based on date\n* If historical data cannot change (has been reported, though inaccurate) \n    then may need 2 sets of dates  (operational\u002F booking)\n\n#### Late-arriving dimension rows (applied to slowly changing dimensions)\n\n* Insert new row with new surrogate key\n* Scan forwards from this date and correct later rows with same natural key\n* Update all fact rows to correct surrogate key\n\n\nThe summary of traps to avoid on P326 is well worth reading too.  \nIn order to improve performance of the ETL you can use a cyclic redundancy checksum (CRC) algorithm on dimension staging tables.  \nThis is a more efficient way to determine if row has been updated than comparing each column. "}</script></div>
	</body>
</html>
