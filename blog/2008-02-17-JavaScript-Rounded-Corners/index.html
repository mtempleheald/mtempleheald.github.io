<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="/favicon.ico" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />

		<meta http-equiv="content-security-policy" content="">
	<link rel="stylesheet" href="/_app/assets/pages/__layout.svelte-711b4112.css">
	<link rel="modulepreload" href="/_app/start-e82316e2.js">
	<link rel="modulepreload" href="/_app/chunks/vendor-5ca848cc.js">
	<link rel="modulepreload" href="/_app/pages/__layout.svelte-8da8bfc2.js">
	<link rel="modulepreload" href="/_app/pages/blog/_slug_.svelte-db98abb9.js">
	</head>
	<body>
		<div>



<div class="svelte-1lrvsco"><header><h1 class="svelte-1lrvsco">Mark Temple-Heald</h1>
  <h2 class="svelte-1lrvsco">the right tool for the job</h2></header>

<nav class="svelte-r02kv1"><ul class="svelte-r02kv1"><li class="svelte-r02kv1"><a href="/" class="navAnchor">Home</a></li>
    <li class="svelte-r02kv1"><a href="/blog" class="navAnchor">Blog</a></li>
    <li class="svelte-r02kv1"><a href="/topic" class="navAnchor">Topic</a></li>
    <li class="svelte-r02kv1"><a href="/about" class="navAnchor">About</a></li></ul>
</nav>
</div>

<main class="svelte-lv7236"><!-- HTML_TAG_START --><h1>Rounded corners using JavaScript without CSS3</h1>This page is no longer displaying due to incompatibility with Sveltekit and my laziness.
So I've included the scripts inline below instead.<br /><pre class="code js"><code class="language-js">&lt;script src=&quot;/assets/js/RoundCorners.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</code></pre><br /><div markdown="1" class="rounded-example" style="background-color: lightsteelblue; color: blue; margin: 10px;"><br />  Before CSS3 introduced the border-radius property rounded corners were achieved on the web using 4 tiny images, held in location using div soup.<br />  There was no separation of content from styles, ugly to maintain and inflexible to change.<br />  I figured that JavaScript could fill the gap for me, so I built this.<br /></div><br /><div markdown="1" class="rounded-example" style="background-color: lightsteelblue; color: blue; margin: 10px;"><br />  It is quite simple, using the ellipse equation x&sup2;/a&sup2; + y&sup2;/b&sup2; = 1 <br /><ol><li>Find div(s) with given tag.</li><li>Infer the background-color of this element and its parent.</li><li>Loop through, pixel by pixel, the height of the curve (10 in this example)</li><li>Loop through, pixel by pixel, the width of the curve (again 10 in this example)</li><li>Calculate the colour needed to blend smoothly between the child and parent element (antialiasing)</li><li>Create a new div, positioned appropriately that when all combined we see a curve.</li></ol><br /></div><br /><div markdown="1" class="rounded-example" style="background-color: lightsteelblue; color: blue; margin: 10px;"><br />  This solution is far from perfect but was sufficient for my needs, notable issues:<br /><ul><li>increases the size of the div by the vertical curve depth chosen</li><li>only works with divs, which wasn't a problem when I wrote this prior to HTML5 semantic markup</li><li>redundant with the introduction of border-radius</li></ul><br /></div><br /><pre class="code js"><code class="language-js">&lt;script type=&quot;text/javascript&quot;&gt;
  RoundCorners(&quot;rounded-example&quot;,10,10,1,1,1,1);
&lt;/script&gt;</code></pre><hr /><h2>RoundCorners.js</h2><pre class="code javascript"><code class="language-javascript">function Check() {						//Check if browser supports this, if not then quit
	if(!document.getElementById || !document.createElement) {
	    return false;
	}
	var b = navigator.userAgent.toLowerCase();
	if (b.indexOf(&quot;msie 5&quot;) &gt; 0 && b.indexOf(&quot;opera&quot;) == -1) {
		return false;
	}
	return true;
}

function Blend(a, b, alpha) {				//Returns a colour equal to a blend of the fore and background colours
	var fgc = [];
		fgc[0] = parseInt('0x' + a.substring(1, 3),16);
		fgc[1] = parseInt('0x' + a.substring(3, 5),16);
		fgc[2] = parseInt('0x' + a.substring(5, 7),16);
	var bgc = [];
		bgc[0] = parseInt('0x' + b.substring(1, 3),16);
		bgc[1] = parseInt('0x' + b.substring(3, 5),16);
		bgc[2] = parseInt('0x' + b.substring(5, 7),16);
	return '#'+ ('0'+Math.round(fgc[0] + (bgc[0] - fgc[0])*alpha).toString(16)).slice(-2).toString(16) +
				('0'+Math.round(fgc[1] + (bgc[1] - fgc[1])*alpha).toString(16)).slice(-2).toString(16) +
				('0'+Math.round(fgc[2] + (bgc[2] - fgc[2])*alpha).toString(16)).slice(-2).toString(16);
}

function rgb2hex(value) {
	var hex = '';
	var i;
	var regexp=/([0-9]+)[, ]+([0-9]+)[, ]+([0-9]+)/;
	var array = [];
	array = regexp.exec(value);
	for(i=1;i&lt;4;i++) {
		hex += ('0'+parseInt(array[i],10).toString(16)).slice(-2);
	}
	return '#'+hex;
}

function getDivStyle(xdiv, IEStyleAttr, CSSStyleAttr) {
  var elem = xdiv;
	var xproperty;
  if (elem.currentStyle) {
      xproperty = elem.currentStyle[IEStyleAttr];
  } 
	else if (window.getComputedStyle) {
      var compStyle = window.getComputedStyle(elem, &quot;&quot;);
      xproperty = rgb2hex(compStyle.getPropertyValue(CSSStyleAttr));
  }
	else {
		return &quot;transparent&quot;;
	}
	return xproperty;
}

function getDivs(className) {			//Create array of divs with class='rounded'
	var divs = [];
	var el = document.getElementsByTagName('div');  //create an array containing ALL divs on the page
	var regexp=new RegExp(&quot;\\b&quot;+className+&quot;\\b&quot;);
	for (var i = 0; i &lt; el.length; i++) {
		if (regexp.test(el[i].className)) {		//If div has class='rounded'...
			divs.push(el[i]);					//add to divs array
		}
	}
	return divs;					//return array
}

Math.sqr = function (x) {
	return x*x;
}; 

function MakeDivs(divSquare, bgcolour, colour, radiusx, radiusy, topl, topr, botl, botr) {
	var divT = document.createElement(&quot;div&quot;);			//Create top container div
		divT.style.backgroundColor = bgcolour;
	var divB = document.createElement(&quot;div&quot;);			//Create bottom container div
		divB.style.backgroundColor = bgcolour;
	var marginArr = [];
	var y, newMargin, k, bgcount, fgcount, blendcount;
	var subdivT, subdivB, divTempT, divTempB, blendratio, u1, u2, v1, v2;
//Create an array representing margins...
	marginArr.push(radiusx);
	for (y = 1; y &lt;= radiusy; y++) {
		newMargin = radiusx * (1.0 - Math.sqrt(1.0 - Math.sqr((radiusy - y)/ radiusy)));
		marginArr.push(Math.round(newMargin*10000)/10000); 		//Calculate x for given y to 4 d.p.s, add to array...
//Build divs based on the array values...
		bgcount = Math.floor(marginArr[y]);				//number of pixels on row which are background
		fgcount = radiusx - Math.ceil(marginArr[y-1]);	//number of pixels on row which are foreground
		blendcount = radiusx - bgcount - fgcount;		//number of pixels on row which are blended between the two
		subdivT = document.createElement(&quot;div&quot;);			//Create row wrapper div with margins set by bgcount and options in function call
		subdivT.style.margin = &quot;0px &quot; + (topr * bgcount) + &quot;px 0px &quot; + (topl * bgcount) + &quot;px&quot;;
		subdivT.style.height = &quot;1px&quot;;
		subdivT.style.overflow = &quot;hidden&quot;;
		subdivB = document.createElement(&quot;div&quot;);			//Create row wrapper div with margins set by bgcount and options in function call
		subdivB.style.margin = &quot;0px &quot; + (botr * bgcount) + &quot;px 0px &quot; + (botl * bgcount) + &quot;px&quot;;
		subdivB.style.height = &quot;1px&quot;;
		subdivB.style.overflow = &quot;hidden&quot;;
		divTempT = divT;
		divTempB = divB;
//Create wrapper for each blended pixel...
		for (k = 1; k &lt;= blendcount; k++) {
			//calculate x when y is at pixel edge  &  y when x is at pixel edge...
			u1 = marginArr[y]   - (bgcount + k - 1);
			u2 = marginArr[y-1] - (bgcount + k - 1);
			v1 = radiusy * (1.0 - Math.sqrt( 1.0 - Math.sqr((radiusx - (bgcount + k - 1))/ radiusx))) - (y - 1);
			v2 = radiusy * (1.0 - Math.sqrt( 1.0 - Math.sqr((radiusx - (bgcount + k    ))/ radiusx))) - (y - 1);
			//Approximate to 0 or 1 if these values lie outside the box (to ensure that blendratio stays between 0 and 1)...
			if (u1 &lt; 0) {u1 = 0;}
			else if (u1 &gt; 1) {u1 = 1;}
			if (u2 &lt; 0) {u2 = 0;}
			else if (u2 &gt; 1) {u2 = 1;}
			if (v1 &lt; 0) {v1 = 0;}
			else if (v1 &gt; 1) {v1 = 1;}
			if (v2 &lt; 0) {v2 = 0;}
			else if (v2 &gt; 1) {v2 = 1;}
			//calculate blendratio (accurate when slope cuts through both sides OR both top and bottom, 1 of each results in approximation)...
			blendratio = 1 - (0.5 * (u1 + u2) * (v1 + v2));
			if (blendratio &gt; 1) {blendratio = 1;}
			else if (blendratio &lt; 0) {blendratio = 0;}
			subdivT.style.backgroundColor = Blend(bgcolour, colour, blendratio);
			divTempT.appendChild(subdivT);					//add div within containing div (first div appended within top container div)
			divTempT = subdivT;
			subdivT = document.createElement(&quot;div&quot;);
			subdivT.style.margin = &quot;0px &quot; + topr + &quot;px 0px &quot; + topl + &quot;px&quot;;
			subdivT.style.height = &quot;1px&quot;;
			subdivT.style.overflow = &quot;hidden&quot;;
			subdivB.style.backgroundColor = Blend(bgcolour, colour, blendratio);
			divTempB.insertBefore(subdivB,divTempB.firstChild);
			divTempB = subdivB;
			subdivB = document.createElement(&quot;div&quot;);
			subdivB.style.margin = &quot;0px &quot; + botr + &quot;px 0px &quot; + botl + &quot;px&quot;;
			subdivB.style.height = &quot;1px&quot;;
			subdivB.style.overflow = &quot;hidden&quot;;
		}
		subdivT.style.backgroundColor = colour;
		subdivB.style.backgroundColor = colour;
		divTempT.appendChild(subdivT);						//add final nested div (foreground)
		divTempB.insertBefore(subdivB,divTempB.firstChild);
	}
	divSquare.insertBefore(divT,divSquare.firstChild);	//add top div to html before the div we are rounding
	divSquare.appendChild(divB);
}
	
function RoundCorners(className, radiusx, radiusy, topl, topr, botl, botr) {
	//if (!Check()) return;
	var bgcolour, colour;
	var v = getDivs(className);			//Create array of divs with class='rounded'
	var l = v.length;					//Count number of entries in the array
	for (var i = 0; i &lt; l; i++) {		//Do for each entry in the array
		colour = getDivStyle(v[i], &quot;backgroundColor&quot;, &quot;background-color&quot;);
		bgcolour = getDivStyle(v[i].parentNode, &quot;backgroundColor&quot;, &quot;background-color&quot;);
		MakeDivs(v[i], bgcolour, colour, radiusx, radiusy, topl, topr, botl, botr);
	}
}</code></pre><!-- HTML_TAG_END --></main>


<footer class="svelte-14g1sgx"><p>This is my site, there are many like it but this one is mine.</p>
  <p>If you don&#39;t like it, you know where the close button is.</p>
  <a href="https://www.linkedin.com/in/mtempleheald" target="_blank" class="svelte-14g1sgx">Mark Temple-Heald</a>
  <a href="https://mtempleheald.github.io" target="_blank" class="svelte-14g1sgx">Home</a>
  <a href="https://github.com/mtempleheald" target="_blank" class="svelte-14g1sgx">GitHub</a>
  <p>Mindful meanderings manifest more manageable machinations.
    Manoeuvring murky multifaceted modernism means meticulously managing many mistakes, misconceptions, misunderstandings.
    Measured multipronged musings, mechanical movements, may maximise meritorious magnificence.
  </p>
</footer>


		<script type="module" data-hydrate="1l07csu">
		import { start } from "/_app/start-e82316e2.js";
		start({
			target: document.querySelector('[data-hydrate="1l07csu"]').parentNode,
			paths: {"base":"","assets":""},
			session: {},
			route: true,
			spa: false,
			trailing_slash: "never",
			hydrate: {
				status: 200,
				error: null,
				nodes: [
					import("/_app/pages/__layout.svelte-8da8bfc2.js"),
						import("/_app/pages/blog/_slug_.svelte-db98abb9.js")
				],
				url: new URL("http://sveltekit-prerender/blog/2008-02-17-JavaScript-Rounded-Corners"),
				params: {slug:"2008-02-17-JavaScript-Rounded-Corners"}
			}
		});
	</script><script type="application/json" data-type="svelte-data" data-url="/api/blogs/2008-02-17-JavaScript-Rounded-Corners">{"status":200,"statusText":"","headers":{"content-type":"text/plain;charset=UTF-8"},"body":"# Rounded corners using JavaScript without CSS3\n\nThis page is no longer displaying due to incompatibility with Sveltekit and my laziness.\nSo I've included the scripts inline below instead.\n\n\n```js\n\u003Cscript src=\"\u002Fassets\u002Fjs\u002FRoundCorners.js\" type=\"text\u002Fjavascript\"\u003E\u003C\u002Fscript\u003E\n```\n\n\n\n\u003Cdiv markdown=\"1\" class=\"rounded-example\" style=\"background-color: lightsteelblue; color: blue; margin: 10px;\"\u003E\n\n  Before CSS3 introduced the border-radius property rounded corners were achieved on the web using 4 tiny images, held in location using div soup.  \n  There was no separation of content from styles, ugly to maintain and inflexible to change.  \n  I figured that JavaScript could fill the gap for me, so I built this.\n\n\u003C\u002Fdiv\u003E\n\n\u003Cdiv markdown=\"1\" class=\"rounded-example\" style=\"background-color: lightsteelblue; color: blue; margin: 10px;\"\u003E\n\n  It is quite simple, using the ellipse equation x&sup2;\u002Fa&sup2; + y&sup2;\u002Fb&sup2; = 1   \n1. Find div(s) with given tag.\n2. Infer the background-color of this element and its parent.\n3. Loop through, pixel by pixel, the height of the curve (10 in this example)\n4. Loop through, pixel by pixel, the width of the curve (again 10 in this example)\n5. Calculate the colour needed to blend smoothly between the child and parent element (antialiasing)\n6. Create a new div, positioned appropriately that when all combined we see a curve.\n\n\u003C\u002Fdiv\u003E\n\n\u003Cdiv markdown=\"1\" class=\"rounded-example\" style=\"background-color: lightsteelblue; color: blue; margin: 10px;\"\u003E\n\n  This solution is far from perfect but was sufficient for my needs, notable issues:  \n* increases the size of the div by the vertical curve depth chosen\n* only works with divs, which wasn't a problem when I wrote this prior to HTML5 semantic markup\n* redundant with the introduction of border-radius\n\n\u003C\u002Fdiv\u003E\n\n```js\n\u003Cscript type=\"text\u002Fjavascript\"\u003E\n  RoundCorners(\"rounded-example\",10,10,1,1,1,1);\n\u003C\u002Fscript\u003E\n```\n\n---\n\n## RoundCorners.js\n\n```javascript\n  function Check() {\t\t\t\t\t\t\u002F\u002FCheck if browser supports this, if not then quit\n\tif(!document.getElementById || !document.createElement) {\n\t    return false;\n\t}\n\tvar b = navigator.userAgent.toLowerCase();\n\tif (b.indexOf(\"msie 5\") \u003E 0 && b.indexOf(\"opera\") == -1) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nfunction Blend(a, b, alpha) {\t\t\t\t\u002F\u002FReturns a colour equal to a blend of the fore and background colours\n\tvar fgc = [];\n\t\tfgc[0] = parseInt('0x' + a.substring(1, 3),16);\n\t\tfgc[1] = parseInt('0x' + a.substring(3, 5),16);\n\t\tfgc[2] = parseInt('0x' + a.substring(5, 7),16);\n\tvar bgc = [];\n\t\tbgc[0] = parseInt('0x' + b.substring(1, 3),16);\n\t\tbgc[1] = parseInt('0x' + b.substring(3, 5),16);\n\t\tbgc[2] = parseInt('0x' + b.substring(5, 7),16);\n\treturn '#'+ ('0'+Math.round(fgc[0] + (bgc[0] - fgc[0])*alpha).toString(16)).slice(-2).toString(16) +\n\t\t\t\t('0'+Math.round(fgc[1] + (bgc[1] - fgc[1])*alpha).toString(16)).slice(-2).toString(16) +\n\t\t\t\t('0'+Math.round(fgc[2] + (bgc[2] - fgc[2])*alpha).toString(16)).slice(-2).toString(16);\n}\n\nfunction rgb2hex(value) {\n\tvar hex = '';\n\tvar i;\n\tvar regexp=\u002F([0-9]+)[, ]+([0-9]+)[, ]+([0-9]+)\u002F;\n\tvar array = [];\n\tarray = regexp.exec(value);\n\tfor(i=1;i\u003C4;i++) {\n\t\thex += ('0'+parseInt(array[i],10).toString(16)).slice(-2);\n\t}\n\treturn '#'+hex;\n}\n\nfunction getDivStyle(xdiv, IEStyleAttr, CSSStyleAttr) {\n    var elem = xdiv;\n\tvar xproperty;\n    if (elem.currentStyle) {\n        xproperty = elem.currentStyle[IEStyleAttr];\n    } \n\telse if (window.getComputedStyle) {\n        var compStyle = window.getComputedStyle(elem, \"\");\n        xproperty = rgb2hex(compStyle.getPropertyValue(CSSStyleAttr));\n    }\n\telse {\n\t\treturn \"transparent\";\n\t}\n\treturn xproperty;\n}\n\nfunction getDivs(className) {\t\t\t\u002F\u002FCreate array of divs with class='rounded'\n\tvar divs = [];\n\tvar el = document.getElementsByTagName('div');  \u002F\u002Fcreate an array containing ALL divs on the page\n\tvar regexp=new RegExp(\"\\\\b\"+className+\"\\\\b\");\n\tfor (var i = 0; i \u003C el.length; i++) {\n\t\tif (regexp.test(el[i].className)) {\t\t\u002F\u002FIf div has class='rounded'...\n\t\t\tdivs.push(el[i]);\t\t\t\t\t\u002F\u002Fadd to divs array\n\t\t}\n\t}\n\treturn divs;\t\t\t\t\t\u002F\u002Freturn array\n}\n\nMath.sqr = function (x) {\n\treturn x*x;\n}; \n\nfunction MakeDivs(divSquare, bgcolour, colour, radiusx, radiusy, topl, topr, botl, botr) {\n\tvar divT = document.createElement(\"div\");\t\t\t\u002F\u002FCreate top container div\n\t\tdivT.style.backgroundColor = bgcolour;\n\tvar divB = document.createElement(\"div\");\t\t\t\u002F\u002FCreate bottom container div\n\t\tdivB.style.backgroundColor = bgcolour;\n\tvar marginArr = [];\n\tvar y, newMargin, k, bgcount, fgcount, blendcount;\n\tvar subdivT, subdivB, divTempT, divTempB, blendratio, u1, u2, v1, v2;\n\u002F\u002FCreate an array representing margins...\n\tmarginArr.push(radiusx);\n\tfor (y = 1; y \u003C= radiusy; y++) {\n\t\tnewMargin = radiusx * (1.0 - Math.sqrt(1.0 - Math.sqr((radiusy - y)\u002F radiusy)));\n\t\tmarginArr.push(Math.round(newMargin*10000)\u002F10000); \t\t\u002F\u002FCalculate x for given y to 4 d.p.s, add to array...\n\u002F\u002FBuild divs based on the array values...\n\t\tbgcount = Math.floor(marginArr[y]);\t\t\t\t\u002F\u002Fnumber of pixels on row which are background\n\t\tfgcount = radiusx - Math.ceil(marginArr[y-1]);\t\u002F\u002Fnumber of pixels on row which are foreground\n\t\tblendcount = radiusx - bgcount - fgcount;\t\t\u002F\u002Fnumber of pixels on row which are blended between the two\n\t\tsubdivT = document.createElement(\"div\");\t\t\t\u002F\u002FCreate row wrapper div with margins set by bgcount and options in function call\n\t\tsubdivT.style.margin = \"0px \" + (topr * bgcount) + \"px 0px \" + (topl * bgcount) + \"px\";\n\t\tsubdivT.style.height = \"1px\";\n\t\tsubdivT.style.overflow = \"hidden\";\n\t\tsubdivB = document.createElement(\"div\");\t\t\t\u002F\u002FCreate row wrapper div with margins set by bgcount and options in function call\n\t\tsubdivB.style.margin = \"0px \" + (botr * bgcount) + \"px 0px \" + (botl * bgcount) + \"px\";\n\t\tsubdivB.style.height = \"1px\";\n\t\tsubdivB.style.overflow = \"hidden\";\n\t\tdivTempT = divT;\n\t\tdivTempB = divB;\n\u002F\u002FCreate wrapper for each blended pixel...\n\t\tfor (k = 1; k \u003C= blendcount; k++) {\n\t\t\t\u002F\u002Fcalculate x when y is at pixel edge  &  y when x is at pixel edge...\n\t\t\tu1 = marginArr[y]   - (bgcount + k - 1);\n\t\t\tu2 = marginArr[y-1] - (bgcount + k - 1);\n\t\t\tv1 = radiusy * (1.0 - Math.sqrt( 1.0 - Math.sqr((radiusx - (bgcount + k - 1))\u002F radiusx))) - (y - 1);\n\t\t\tv2 = radiusy * (1.0 - Math.sqrt( 1.0 - Math.sqr((radiusx - (bgcount + k    ))\u002F radiusx))) - (y - 1);\n\t\t\t\u002F\u002FApproximate to 0 or 1 if these values lie outside the box (to ensure that blendratio stays between 0 and 1)...\n\t\t\tif (u1 \u003C 0) {u1 = 0;}\n\t\t\telse if (u1 \u003E 1) {u1 = 1;}\n\t\t\tif (u2 \u003C 0) {u2 = 0;}\n\t\t\telse if (u2 \u003E 1) {u2 = 1;}\n\t\t\tif (v1 \u003C 0) {v1 = 0;}\n\t\t\telse if (v1 \u003E 1) {v1 = 1;}\n\t\t\tif (v2 \u003C 0) {v2 = 0;}\n\t\t\telse if (v2 \u003E 1) {v2 = 1;}\n\t\t\t\u002F\u002Fcalculate blendratio (accurate when slope cuts through both sides OR both top and bottom, 1 of each results in approximation)...\n\t\t\tblendratio = 1 - (0.5 * (u1 + u2) * (v1 + v2));\n\t\t\tif (blendratio \u003E 1) {blendratio = 1;}\n\t\t\telse if (blendratio \u003C 0) {blendratio = 0;}\n\t\t\tsubdivT.style.backgroundColor = Blend(bgcolour, colour, blendratio);\n\t\t\tdivTempT.appendChild(subdivT);\t\t\t\t\t\u002F\u002Fadd div within containing div (first div appended within top container div)\n\t\t\tdivTempT = subdivT;\n\t\t\tsubdivT = document.createElement(\"div\");\n\t\t\tsubdivT.style.margin = \"0px \" + topr + \"px 0px \" + topl + \"px\";\n\t\t\tsubdivT.style.height = \"1px\";\n\t\t\tsubdivT.style.overflow = \"hidden\";\n\t\t\tsubdivB.style.backgroundColor = Blend(bgcolour, colour, blendratio);\n\t\t\tdivTempB.insertBefore(subdivB,divTempB.firstChild);\n\t\t\tdivTempB = subdivB;\n\t\t\tsubdivB = document.createElement(\"div\");\n\t\t\tsubdivB.style.margin = \"0px \" + botr + \"px 0px \" + botl + \"px\";\n\t\t\tsubdivB.style.height = \"1px\";\n\t\t\tsubdivB.style.overflow = \"hidden\";\n\t\t}\n\t\tsubdivT.style.backgroundColor = colour;\n\t\tsubdivB.style.backgroundColor = colour;\n\t\tdivTempT.appendChild(subdivT);\t\t\t\t\t\t\u002F\u002Fadd final nested div (foreground)\n\t\tdivTempB.insertBefore(subdivB,divTempB.firstChild);\n\t}\n\tdivSquare.insertBefore(divT,divSquare.firstChild);\t\u002F\u002Fadd top div to html before the div we are rounding\n\tdivSquare.appendChild(divB);\n}\n\t\nfunction RoundCorners(className, radiusx, radiusy, topl, topr, botl, botr) {\n\t\u002F\u002Fif (!Check()) return;\n\tvar bgcolour, colour;\n\tvar v = getDivs(className);\t\t\t\u002F\u002FCreate array of divs with class='rounded'\n\tvar l = v.length;\t\t\t\t\t\u002F\u002FCount number of entries in the array\n\tfor (var i = 0; i \u003C l; i++) {\t\t\u002F\u002FDo for each entry in the array\n\t\tcolour = getDivStyle(v[i], \"backgroundColor\", \"background-color\");\n\t\tbgcolour = getDivStyle(v[i].parentNode, \"backgroundColor\", \"background-color\");\n\t\tMakeDivs(v[i], bgcolour, colour, radiusx, radiusy, topl, topr, botl, botr);\n\t}\n}\n```"}</script></div>
	</body>
</html>
